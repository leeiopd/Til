# kafka

## #1. 기존 메세징 시스템과의 차이

- 메세징 큐의 일종
- 말 그대로 `분산형 스트리밍 플랫폼`, LinkedIn에서 여러 구직 + 채용 정보들을 한곳에서 처리(발행/구독)할수 있는 플랫폼으로 개발이 시작
- 대용량의 실시간 로그 처리에 특화되어 설계된 메시징 시스템, 기존 범용 메시징 시스템대비 TPS가 매우 우수
- 메시지를 기본적으로 메모리에 저장하는 기존 메시징 시스템과는 달리 메시지를 파일 시스템에 저장 → 카프카 재시작으로 인한 메세지 유실 우려 감소
- 기존의 메시징 시스템에서는 broker가 consumer에게 메시지를 push해 주는 방식인데 반해, Kafka는 consumer가 broker로부터 직접 메시지를 가지고 가는 pull 방식으로 동작하기 때문에 consumer는 자신의 처리능력만큼의 메시지만 broker로부터 가져오기 때문에 최적의 성능을 낼 수 있다.



## #2. 기본 설명

- pub-sub(발행-구독) 모델 

  - 메세지를 특정 수신자에게 직접적으로 보내주는 시스템이 아니라, 메세지를 topic을 통해 카테고리화 한다.
  - 분류된 메세지를 받기 원하는 receiver는 해당 topic을 구독하므로써 메세지를 읽어 올 수 있다.

- Topic 과 partition

  - 메세지는 topic으로 분류되고, topic은 여러개의 partition으로 나눠 질 수 있다.

  - 파티션 내의 한칸은 log라고 불린다.

    - log - 1개의 메세지

  - 데이터는 한칸의 log에 순차적으로 append 된다.

  - 메세지의 상대적인 위치를 나타내는 것이 offset이다.

    - offset - 파티션 내에서 각 메세지가 가지는 unique id

  - 파티션을 늘렸을 때 메세지가 round-robin 방식으로 쓰여진다.

    (순차적으로 메세지가 쓰여지지 않는다는 의미, 메세지의 순서가 엄청 중요한 모델일 경우 위험할 수 있다.)

- producer/consumer

  - producer - 메세지 생산의 주체/ consumer의 존재를 알 수 없다.
  - consumer - 메세지 소비 주체/ producer의 존재를 알 수 없다.
    - 해당 topic을 구독 함으로써, 스스로 조절해 가면서 소비 할 수 있다.
    - offsest의 위치를 기억하는 것으로 소비를 조절 한다.
    - fail-over에 대한 신뢰가 존재 (장애 극복 기능)

- consumer group

  - 반드시 해당 topic의 파티션은 그 contumer group과 1:n 매칭을 해야 한다.
  - 파티션을 늘릴 때, consumer의 개수도 고려 하여야 한다.
  - 보통, 개수를 맞춰주는것을 권장하지만 메시지가 쌓이는 속도가 처리하는 속도보다 빠르다면 `파티션 개수 >= 컨슈머개수`로 설정하는 것도 나쁘지 않다.
  - consumer group 내에서 `파티션 재조정`을 통해 counsumer down에 대응하여 Rebalance 상황을 방지한다.

- broker, zookeeper

  - broker - 카프카의 서버
  - zookeeper - 분산된 메세지 큐의 정보를 관리해주는 역할



## #3. kafka의 동작

1. zookeeper가 kafka의 상태와 클러스터를 관리해 준다.
   * 클러스터 : 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합
2. 정해진 topic 에 producer 가 메세지를 발행해놓으면 consumer 가 필요할때 해당 메세지를 가져간다. 
   * 카프카로 발행된 메세지들은 consumer가 메세지를 소비한다고 해서 없어지는게 아니라 카프카 설정`log.retention.hours(default : 168[7일])`에 의해 삭제된다.)