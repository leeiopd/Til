# 따배씨 - 따라하며 배우는 C언어

### 14강 구조체_2

##### 14.11 신축성 있는 배열 멤버 Flexible Array Members

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    /*
        Flexible array member (struct hack in GCC)
        // 지금은 표준
     */
    
    struct flex
    {
        size_t count;
        double average;
        double values[];    // flexible array member (last member!)
        // 구조체가 저장되는 메모리 구조상, flexible array 변수 위치를 마지막으로 두어야 사용하기 편함
    };
    
    const size_t n = 3;
    
    struct flex* pf = (struct flex*)malloc(sizeof(struct flex) + n * sizeof(double));
    // values 의 배열 크기 n 만큼 추가 동적할당
    
    if (pf == NULL) exit(1);
    
    printf("flexible array member\n");
    printf("Sizeof struct flex %zd\n", sizeof(struct flex));
    // Sizeof struct flex 16
    printf("Sizeof *pf %zd\n", sizeof(pf));
    // Sizeof *pf 8
    printf("Sizeof malloc %zd\n", sizeof(struct flex) + n * sizeof(double));
    // Sizeof malloc 40
    printf("%lld\n", (long long)pf);
    // 4388333424
    printf("%lld\n", (long long)& pf->count);
    // 4388333424
    printf("%zd\n", sizeof(pf->count));
    // 8
    printf("%lld\n", (long long)& pf->average);
    // 4388333432
    printf("Address of pf->values %lld\n", (long long)& pf->values);
    // Address of pf->values 4388333440
    printf("Value of pf->values %lld\n", (long long)pf->values);
    // Value of pf->values 4388333440
//    printf("Sizeof pf->value %zd\n", sizeof(pf->values));
    
    pf->count = n;
    // 동적 할당을 받은 크기를 저장해 둠
    pf->values[0] = 1.1;
    pf->values[1] = 2.1;
    pf->values[2] = 3.1;
    
    pf->average = 0.0;
    for (unsigned i = 0; i < pf->count; ++i)
        pf->average += pf->values[i];
    pf->average /= (double)pf->count;
    
    printf("Average = %f\n", pf->average);
    // Average = 2.100000
    
    return 0;
}
```

* ```c
  struct flex
      {
          size_t count;
          double average;
          double values[];    // flexible array member (last member!)
      };
  ```
  * 구조체가 저장되는 메모리 구조상, flexible array 변수 위치를 마지막으로 두어야 사용하기 편함

  * ```c
    double values[];
    ```

    * 배열의 크기가 지정되지 않았기 때문에, 메모리 크기가 없는상태
    * 동적할당을 받아야지 메모리 크기가 할당 됨



```c
struct nonflex
{
  size_t count;
  double average;
  double *values; // Use malloc()
};

struct  nonflex nf;
int n = 3;
nf.values = (double *)malloc(sizeof(double) * n);
```

* ```c
  double *values;
  nf.values = (double *)malloc(sizeof(double) * n);
  ```

  * 동적 할당 배열

  * ```c
    double *values;
    ```

    * pointer 변수가 저장될 메모리 크기를 할당 받음
    * 동적 할당된 array 의 주소는 구조체의 메모리 주소와 별도로 생성
      * 연관 X

```c
struct flex* pf = (struct flex*)malloc(sizeof(struct flex) + n * sizeof(double));

if(pf == NULL) exit(1);

*pf2 = *pf1;	// Don't copy flexible members, use memcpy() instead

printf("%f %f %f\n", pf->values[0], pf->values[1], pf->values[2]);
// 1.100000 2.100000 3.100000

printf("%f %f %f\n", pf2->values[0], pf2->values[1],pf2->values[2]);
// 0.000000 0.000000 0.000000
```

* flexible array member 는 대입 하는 방법으로는 제대로 복사 되지 않음
  * compiler 입장에서 동적 할당을 받은 size 까지 알 수 없기 때문에, 기본 size 까지만 복사가 됨
  * memcpy() 를 사용하여 값을 복사해야 함



##### 14.12 익명 구조체 Anonymous Structures

```c
#include <stdio.h>

struct names
{
    char first[20];
    char last[20];
};

struct person
{
    int id;
    struct names name;  // nested strucutre member
};

struct person2
{
    int id;
    struct { char first[20]; char last[20]; };    // anomymous strucutre
};

int main()
{
    struct person ted = { 123, {"Bill", "Gates"}};
    struct person ted3 = { 125, {"Robert", "Hand"}};
    
    puts(ted.name.first);
    // Bill
    puts(ted3.name.first);
    // Robert
    
    struct person2 ted2 = { 124, {"Steve", "wozniak"}};
    // Steve
		// struct person2 ted2 = { 124, "Steve", "wozniak"};   // also works
    
    puts(ted2.first);
    
    return 0;
}
```

* ```c
  struct person2
  {
      int id;
      struct { char first[20]; char last[20]; };    // anomymous strucutre
  };
  
  struct person2 ted2 = { 124, {"Steve", "wozniak"}};
  // or //struct person2 ted2 = { 124, "Steve", "wozniak"};
  
  puts(ted2.first);
  ```
  * ```c
    puts(ted2.first);
    ```

    * 익명 구조체가 멤버일 때에는, 익명 구조체의 멤버로 바로 접근이 가능함



##### 14.13 구조체의 배열을 사용하는 함수

```c
#include <stdio.h>

#define SLEN 101

struct book
{
    char name[SLEN];
    char author[SLEN];
};

void print_books(const struct book books[], int n);

int main()
{
    struct book my_books[3];    // = {"The Great Gatsby", "F. Scott Fitzgerald"},...};
    
    my_books[0] = (struct book){"The Great Gatsby", "F. Scott Fitzgerald"};
    my_books[1] = (struct book){"Hamlet", "William Shakespeare"};
    my_books[2] = (struct book){"The Odyssey", "Homer"};
    
    print_books(my_books, 3);
    
    return 0;
}

void print_books(const struct book books[], int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("Book %d :\"%s\" written by \"%s\"\n", i + 1, books[i].name, books[i].author);
    }
}
```

* 구조체 배열 사용



```c
#include <stdio.h>
#include <stdlib.h>

#define SLEN 101

struct book
{
    char name[SLEN];
    char author[SLEN];
};

void print_books(const struct book books[], int n);

int main()
{
    struct book* my_books = (struct book*)malloc(sizeof(struct book) * 3);
    
    if (!my_books) exit(1);
    
    my_books[0] = (struct book){"The Great Gatsby", "F. Scott Fitzgerald"};
    my_books[1] = (struct book){"Hamlet", "William Shakespeare"};
    my_books[2] = (struct book){"The Odyssey", "Homer"};
    
    print_books(my_books, 3);
    
    return 0;
}

void print_books(const struct book* books, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("Book %d :\"%s\" written by \"%s\"\n", i + 1, books[i].name, books[i].author);
    }
}
```

* 구조체 배열을 pointer 로 구현



 ##### 14.14 구조체 파일 입출력 연습문제

``` c
#include <stdio.h>
#include <stdlib.h>

#define SLEN 101

struct book
{
    char name[SLEN];
    char author[SLEN];
};

void print_books(const struct book * books, int n);
void write_books(const char * filename, const struct book* books, int n);
struct book* read_books(const char* filename, int* n);
void read_books2(const char* filename,struct book **books_dptr, int* n);

int main()
{
    int temp;
    int n = 3;
    
    struct book* my_books = (struct book*)malloc(sizeof(struct book) * n);
    
    if (!my_books)
    {
        printf("Malloc failed");
        exit(1);
    }
    
    my_books[0] = (struct book){"The Grat Gatsby", "F. Scott Fitzgerald"};
    my_books[1] = (struct book){"Hamlet", "William Shakespeare"};
    my_books[2] = (struct book){"The Odyssey", "Homer"};
    
    print_books(my_books, n);
    
    printf("\nWriting to a file.\n");
    write_books("books.txt", my_books, n);
    free(my_books);
    my_books = NULL;
    n = 0;
    printf("Done.\n");
    
    printf("\nPress any key to read data from a file.\n\n");
    temp = getchar();
    
//    my_books = read_books("books.txt", &n);
    read_books2("books.txt", &my_books, &n);
    
    print_books(my_books, n);
    free(my_books);
    my_books = NULL;
    n = 0;
    
    return 0;
}

void print_books(const struct book * books, int n)
{
    for (int i  = 0; i < n; ++i)
        printf("Book %d : \"%s\" wrriten by \"%s\"\n", i, books[i].name, books[i].author);
}

void write_books(const char * filename, const struct book* books, int n)
{
    FILE* file = fopen(filename, "w");
    
    if (file == NULL)
    {
        fputs("Can't open file", stderr);
        exit(1);
    }
    
    fprintf(file, "%d\n", n);   // number of books
    
    for (int i = 0; i < n; ++i)
    {
        fprintf(file, "%s\n%s\n", books[i].name, books[i].author);
    }
    
    fclose(file);
}

struct book* read_books(const char* filename, int* n_ptr)
{
    FILE* file = fopen(filename, "r");
    
    if(file==NULL)
    {
        fputs("Can't open file", stderr);
        exit(1);
    }
    
    int flag;
    flag = fscanf(file, "%d%*c", n_ptr);    // Remove last '\n'
    if (flag != 1)
    {
        printf("File read failed");
        exit(1);
    }
    
    struct book* books = (struct book*)calloc(sizeof(struct book), *n_ptr);
    
    if (!books)
    {
        printf("Malloc() Fail.");
        exit(1);
    }
    
    for (int i = 0; i < *n_ptr; ++i)
    {
        flag = fscanf(file, "%[^\n]%*c%[^\n]%*c", books[i].name, books[i].author);
        
        if (flag != 2)
        {
            printf("File read failed");
            exit(1);
        }
    }
    
    return books;
};

void read_books2(const char* filename,struct book **books_dptr, int* n_ptr)
{
    FILE* file = fopen(filename, "r");
    
    if (file==NULL)
    {
        fputs("Can't open file", stderr);
        exit(1);
    }
    
    int flag;
    flag = fscanf(file, "%d%*c", n_ptr);    // Remove last '\n'
    if (flag != 1)
    {
        printf("File read failed");
        exit(1);
    }
    
    struct book* books = (struct book*)calloc(sizeof(struct book), *n_ptr);
    
    if(!books)
    {
        printf("Malloc() failed.");
        exit(1);
    }
    
    for (int i = 0; i < *n_ptr; ++i)
    {
        flag = fscanf(file, "%[^\n]%*c%[^\n]%*c", books[i].name, books[i].author);
        
        if (flag != 2)
        {
            printf("File read failed");
            exit(1);
        }
    }
    fclose(file);
    
    *books_dptr = books;
}
```



```c
// binary format 으로 처리
void write_books(const char * filename, const struct book* books, int n)
{
    FILE* file = fopen(filename, "wb");
    
    if (file == NULL)
    {
        fputs("Can't open file", stderr);
        exit(1);
    }
    
    fwrite(&n, sizeof(n), 1, file); // number of books
    fwrite(books, sizeof(struct book), n, file);
    
    fclose(file);
}


void read_books2(const char* filename,struct book **books_dptr, int* n_ptr)
{
    FILE* file = fopen(filename, "r");
    
    if (file==NULL)
    {
        fputs("Can't open file", stderr);
        exit(1);
    }
    
    fread(n_ptr, sizeof(*n_ptr), 1, file);
    
    struct book* books = (struct book*)calloc(sizeof(struct book), *n_ptr);
    
    if(!books)
    {
        printf("Malloc() failed.");
        exit(1);
    }
    
    fread(books, sizeof(struct book), *n_ptr, file);
    
    fclose(file);
    
    *books_dptr = books;
}
```

* 데이터 양이 많고 속도가 중요할 경우 binary format이 유리함



##### 14.15 공용체 Union 의 원리

```c
#include <stdio.h>

int main()
{
    /*
        Union
        - Store different data types in the same momory space
        - Strucutre vs Union
     */
    
    union my_union
    {
        int i;
        double d;
        char c;
    };
    
    union my_union uni;
    
    printf("%zd\n", sizeof(union my_union));
  	// 8
    printf("%lld\n", (long long)&uni);
  	// 140732920755232
    printf("%lld %lld %lld\n", (long long)&uni.i, (long long)&uni.d, (long long)&uni.c);
  	// 140732920755232 140732920755232 140732920755232
    
    union my_union save[10];
    
    printf("%zd\n", sizeof(save));
  	// 80
    
    return 0;
}

```

* 공용체 union 은 구조체 structure 와 사용법이 유사하나 메모리 공간의 사용에 차이가 있다
  * Union 은 같은 메모리 공간을 다른 type 들이 공유하게 됨
    * 가장 큰 type 의 메모리로 할당 됨



```c
#include <stdio.h>

int main()
{
    /*
        Union of different types
     */
    
    union my_union
    {
        int i;
        double d;
        char c;
    };
    
    union my_union uni1;
    
    uni1.c = 'A';
    printf("%c %x %d\n", uni1.c, (int)uni1.c, uni1.i);
  	// A 41 -272632767
    
    uni1.i = 0;
    uni1.c = 'A';
    printf("%c %x %d\n", uni1.c, (int)uni1.c, uni1.i);
  	// A 41 65
    
    uni1.d = 1.2;
    printf("%d %f %d %c\n", uni1.i, uni1.d, (int)uni1.c, uni1.c);
  	// 858993459 1.200000 51 3
    
    return 0;
}
```

* 메모리를 공유하기 때문에, 덮어쓰는 현상이 발생



```c
#include <stdio.h>

int main()
{
    /*
        Initializing unions
     */
    
    union my_union
    {
        int i;
        double d;
        char c;
    };
    union my_union uni1;
    uni1.i = 0;
    uni1.c = 'A';
    uni1.d = 1.2;
    
    union my_union uni2 = uni1;         // Copy another union
    union my_union uni3 = { 10 };       // First element (member) only
    union my_union uni4 = { .c = 'A' };  // Designated initializer
    union my_union uni5 = { .d = 1.23, .i = 100 };  // Do NOT recommend
    
    printf("%d %f %c\n", uni5.i, uni5.d, uni5.c);
    // 100 0.000000 d
    
    uni1.i = 123;
    uni1.d = 1.2;
    uni1.c = 'k';
    // uni1 = 'k' 로 사용하기 위한 의도가 됨
    
    return 0;
}
```

* 공용체의 선언은 여러 type 을 포함 하지만, 메모리를 공유하기 때문에 초기화는 한가지  type 만 가능



```c
#include <stdio.h>

int main()
{
    /*
        Initializing unions
     */
    
    union my_union
    {
        int i;
        double d;
        char c;
    };
    union my_union uni1;
    uni1.i = 0;
    uni1.c = 'A';
    uni1.d = 1.2;
    
    union my_union* pu = &uni1; // Pointer union
    int x = pu->i;  // -> operator, same as x = fit.digit
    
    uni1.c = 'A';
    double real = 3.14 * uni1.d;    // do NOT recommend
    
    return 0;
}
```

* 공용체 union 은 편리하나, 실수할 가능성이 높으니 유의해야 함



##### 14.16 공용체와 구조체를 함께 사용하기

```c
#include <stdio.h>

/*
    Unions And Structures
 */

struct personal_owner
{
    char rrn1[7];       //Resident Registration Number
    char rrn2[8];       //ex: 830422-1185600
};

struct company_owner
{
    char crn1[4];       //Company Registraton Number
    char crn2[3];       //ex: 111-22-33333
    char crn3[6];
};

union data
{
    struct personal_owner po;
    struct company_owner co;
};

struct car_data
{
    char model[15];
    int status; /* 0 = personal, 1 = company */
    union data ownerinfo;
};

void print_car(struct car_data car)
{
    printf("---------------------------------------\n");
    printf("Car model : %s\n", car.model);
    
    if (car.status == 0) /* 0 = personal, 1 = company */
    {
        printf("Personal owner : %s-%s\n", car.ownerinfo.po.rrn1, car.ownerinfo.po.rrn2);
    }
    else
    {
        printf("Company owner : %s-%s-%s\n", car.ownerinfo.co.crn1, car.ownerinfo.co.crn2, car.ownerinfo.co.crn3);
    }
    printf("---------------------------------------\n");
}

int main()
{
    struct car_data my_car = {.model = "Avante", .status = 0, .ownerinfo.po = {"830422", "1185600"}};
    struct  car_data company_car = {.model = "Sonata", .status = 0, .ownerinfo.co = {"111", "22", "333"}};
    
    print_car(my_car);
    print_car(company_car);
    
    return 0;
}
```

* ```c
  union data
  {
      struct personal_owner po;
      struct company_owner co;
  };
  ```

  * personal_owner 와 company_onwer 구조체를 공용체로 묶어서 처리

* ``` c
  struct car_data
  {
      char model[15];
      int status; /* 0 = personal, 1 = company */
      union data ownerinfo;
  };
  ```
  * status 에 따라 다른 ownerinfo 를 받아 오게 되는데,  union 을 사용하므로써 메모리의 효용을 높임



##### 14.17 익명 공용체  Anonymous Unions

```c
#include <stdio.h>

/*
    Unions And Structures
 */

struct personal_owner
{
    char rrn1[7];       //Resident Registration Number
    char rrn2[8];       //ex: 830422-1185600
};

struct company_owner
{
    char crn1[4];       //Company Registraton Number
    char crn2[3];       //ex: 111-22-33333
    char crn3[6];
};



struct car_data
{
    char model[15];
    int status; /* 0 = personal, 1 = company */
    union
    {
        struct personal_owner po;
        struct company_owner co;
    };
};

void print_car(struct car_data car)
{
    printf("---------------------------------------\n");
    printf("Car model : %s\n", car.model);
    
    if (car.status == 0) /* 0 = personal, 1 = company */
    {
        printf("Personal owner : %s-%s\n", car.po.rrn1, car.po.rrn2);
    }
    else
    {
        printf("Company owner : %s-%s-%s\n", car.co.crn1, car.co.crn2, car.co.crn3);
    }
    printf("---------------------------------------\n");
}

int main()
{
    struct car_data my_car = {.model = "Avante", .status = 0, .po = {"830422", "1185600"}};
    struct  car_data company_car = {.model = "Sonata", .status = 0, .co = {"111", "22", "333"}};
    
    print_car(my_car);
    print_car(company_car);
    
    return 0;
}
```

* ownerinfo union 을 Anonymous Union 으로 변경



```c
#include <stdio.h>
int main(){
    
    struct Vector2D{
        union{
            struct { double x, y; };
            struct { double i, j; };
            struct { double arr[2]; };
        };
    };
    
    typedef struct Vector2D vec2;
    
    vec2 v = { 3.14, 2.99 };
    
    printf("%.2f %.2f\n", v.x, v.y);
  	// 3.14 2.99
    printf("%.2f %.2f\n", v.i, v.j);
  	// 3.14 2.99
    printf("%.2f %.2f\n", v.arr[0], v.arr[1]);
  	// 3.14 2.99
    
    return 0;
}
```

* 좌표값을 x, y / i, j / arr[0], arr[1] 의 형태로 모두 사용가능 하게 된다



##### 14.18 열거형 Enumerated Types

* 정수형 상수가 마치 이름이 있는 것 처럼 사용 할 수 있게 도와줌



```c
#include <stdio.h>

/*
    int c = 0; // red: 0, orange: 1, yellow:2, green:3, ..
    if (c == 2)
        printf("yellow");
    else if (c == 1)
        printf("orange");
    ...
 */

/*
    #define RED     1
    #define ORANGE  2
    #define YELLOW  3
 
    int c = YELLOW;
    if (c == YELLOW)
        printf("yellow");
    else if (c == ORANGE)
        printf("orange");
    ...
 */

int main(){
    
    /*
        Enumerated type
        - Symbolic names to represent integer constants
        - Improve readability and make it easy to maintain
        - enum-specifier (struct-specifier, union-specifier)
     
        Enumerators
        - The symolic constants
     */
    
    enum spectrum { red, orange, yellow, green, blue, violet };
    //              0    1       2       3      4     5
    // 나열되어 있는 정수들에게 이름을 붙여 줌
    
    enum spectrum color;
    color = blue;
    
    if (color == yellow)
        printf("yellow"); //Note: enumerators are not strings
    
    for (color = red; color <= violet; color++) //Note: ++ operator doesn't allow in C++, use type int.
        printf("%d\n", color);
    
    printf("red = %d, orange = %d\n", red, orange);
    
    enum kids { jackjack, dash, snoopy, nano, pitz };
    // nina has a value of 3
    
    enum kids my_kids = nano;
    printf("nano %d %d\n", my_kids, nano);
 	 	
  	return  0;
}
```



```c
#include <stdio.h>

int main(){
    
    enum levels {low = 100, medium = 500, high = 2000};
    
    int score = 800;
    
    if (score > high)
        printf("High score!\n");
    else if (score > medium)
        printf("Good job\n");
        // Good job
    else if (score > low)
        printf("Not bad\n");
    else
        printf("Do your best\n");
    
    
    enum pet { cat, dog = 10, lion, tiger };
    // puma has a value of 11
    
    printf("Cat %d\n", cat);
    // Cat 0
    printf("Lion %d\n", lion);
    // Lion 11
    
    return  0;
}
```

* ```c
  enum pet { cat, dog = 10, lion, tiger };
  ```

  * 숫자를 지정 할 수 있고, 지정된 값을 이어서 증가하여 지정 됨



##### 14.19 열거형 연습문제

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

enum spectrum { red, orange, yellow, green, blue };
const char* colors[] = { "red", "orange", "yellow", "green", "blue" };

#define LEN 30

int main(){
    char choice[LEN] = { 0, };
    enum spectrum color;
    bool color_is_found = false;
    
    while(1)
    {
        printf("Input a color name (empty line to quit):\n");
        
        if (scanf("%[^\n]%*c", choice) != 1)
            break;
        
        for (color = red; color <= blue; color++){
            if (strcmp(choice, colors[color]) == 0){
                color_is_found = true;
                break;
            }
        }
        
        if (color_is_found){
            switch (color) {
                case red:
                    puts("Red roses");
                    break;
                    
                case orange:
                    puts("Oranges are delicious");
                    break;
                    
                case yellow:
                    puts("Yellow sunflowers");
                    break;
                    
                case green:
                    puts("Green apples");
                    break;
            
                case blue:
                    puts("Blue ocean");
                    break;
            }
        }
        else{
            printf("Please try differenct color %s.\n", choice);
        }
        color_is_found = false;
    };
    
    puts("Good bye!");
    
    return 0;
}
```



##### 14.20 이름 공간 공유하기 Namespace

```c
#include <stdio.h>

int iamfunction(){
    return 0;
}

int main(){
    /*
        namespace
        - Identify parts of a program in wich a name is recognized
        - You an use the same name for one variable and one tag.
        - C++: use 'namespace; to use the same identifiers in the duplicated scopes
     */
    
    int myname = 123;
    
    {
        int myname = 345;
        //double myname = 3.14; //ERROR
    }
    
    struct rect {double x; double y;};
    
    // int rect = 123;   // OK in C (Not OK in C++), 권장하지 않음
    struct rect rect = { 1.1, 2.2 };    // struct rect and rect are in different categories, struct 의  name & struct rect 의 name
    
    /*
        typedef struct rect rect;
        rect rect = { 1.1, 2.2 };   //Not OK
     */
    
    //int iamfunction = iamfunction(); //ERROR
    
    return 0;
}
```

* 같은 이름을 다른 용도로 사용하는것은 좋지 않음

