# 따배씨 - 따라하며 배우는 C언어

### 4강 문자열과 형식 맞춘 입출력

```c
#include <stdio.h>

int main(){
    char fruit_name; // stores only one character.
    
    printf("What is your favorite fruit?\n");
    scanf("%c", &fruit_name); // apple
    
    printf("You like %c!\n", fruit_name);
  // You like a!
    
    return 0;
}
```

* 출력결과 한 글자만 나옴
  * char 형은 한글자만 저장되는 메모리가 할당되기 때문
  * 배열을 이용하여 저장공간을 확보



```c
#include <stdio.h>

int main(){
    char fruit_name[40]; // stores only one character.
    
    printf("What is your favorite fruit?\n");
    scanf("%s", fruit_name);
    
    printf("You like %c!\n", fruit_name);
    
    return 0;
}
```

* char fruit_name[40];
  * char type의 저장공간 40개를 확보
  *  40개의 메모리 공간을 대표하는 주소값 한가지만 할당되는 형식
    * fruit_name[40] 자체가 배열을 대표하는 주소값이 됨
* scanf("%s", fruit_name);
  * string 의 출력 형식자는 %s
  * fruit_name 변수 자체가 주소값이 되기 때문에 & 를 사용하지 않아도 됨



##### 4.2 sizeof 연산자

```c
#include <stdio.h>

int main(){
    /* 1. sizeof basic types */
    
    int a = 0;
    unsigned int int_size1 = sizeof a;
    unsigned int int_size2 = sizeof(int);
    unsigned int int_size3 = sizeof(a);
//    함수의 형태로 사용되나 연산자
    
    size_t int_size4 = sizeof(a);
    size_t float_size = sizeof(float);
    
    printf("Size of int type is %u bytes.\n", int_size1);
    printf("Size of int type is %zu bytes.\n", int_size4);
    printf("Size of int type is %zu bytes.\n", float_size);
//    %zu: size_t 에 대응하는 형식 지정자
    
    
    return 0;
}
```

* sizeof 의 표기
  * sizeof a == sizeof(int) == sizeof(a);
* size_t
  * unsigned int 이지만, 운영체제 상에서 가능한 오브젝트의 최대 크기를 저장하도록 할당
    * 32bit 운영체제에서는 32bit unsigned integer, 64bit 에서는 64bit unsigned integer
    * unsigned int 의 경우에는 64bit 운영체제라도 32bit unsigned integer 일 수도 있다는점이 차이
  * %zu: size_t 에 대응하는 형식 지정자



```c
#include <stdio.h>
#include <stdlib.h> // malloc() - memory allocation

int main(){
    /* 2. sizeof arrays */
    
    int int_arr[30];
    
    int* int_ptr = NULL; 
    int_ptr = (int*)malloc(sizeof(int)*30);
    
    printf("Size of array = %zu bytes\n", sizeof(int_arr));

    printf("Size of pointer = %zu bytes\n", sizeof(int_ptr));
 
    
    return 0;
}
```

* ```c
  int* int_ptr = NULL
  ```

  * 포인터를 사용하여 주소값을 저장할수 있는 공간 생성

* ```c
  int_ptr = (int*)malloc(sizeof(int) * 30);
  ```

  * 30개의 정수를 저장 할 수 있는 배열 (메모리 공간) 을 요청
  * 대표하는 메모리 주소(첫번째 주소)를 int_ptr 에 저장

* ```c
  printf("Size of array = %zu bytes\n", sizeof(int_arr));
  ```

  * 정수 30개가 저장될 배열의 메모리 크기인 120 bytes 가 출력됨
    * int_arr[30]의 경우 실제 120byte의 공간을 할당 받음
    * int_arr 이 변수로 사용될 때에만 주소값 형태로 바뀌어 사용된다고 해석 됨
    * 복잡하게 생각할 것 없이 주소값이라고 생각하면 편함

* ```c
  printf("Size of pointer = %zu bytes\n", sizeof(int_ptr));
  ```

  * 배열의 대표 주소값(정수) 이 저장될 공간인 8byte 출력

* int int_arr[30] 선언과 malloc()의 차이

  * int int_arr[30]: 컴파일 되는 120byte를 할당
  * malloc(): 런타임에서 결정됨



```c
#include <stdio.h>

int main(){
    /* 3. sizeof character array */
  
    char c = 'a';
    char string[10];
    
    size_t char_size = sizeof(char);
    size_t str_size = sizeof(string);
    
    printf("Size of char = %zu bytes\n", char_size);	// 1 byte
  
    printf("Size of string = %zu bytes\n", str_size);	// 10 byte
    
    return 0;
}

```

* ```c
  char string[10];
  ```

  * maximally 9 character + '/0' (null character)
  * 저장공간의 마지막에 null character 하나를 저장하여야 하기 때문에 공간 하나를 사용하지 못함



```c
#include <stdio.h>

struct Mystruct
{
    int i;
    float f;
};

int main(){
    /* 4. sizeof structure */
    
    printf("Size of structure = %zu bytes\n", sizeof(struct Mystruct));
    
    return 0;
}
```

* struct(구조체) 의 경우 사용한 자료형의 메모리 합으로 할당 됨



##### 4.3 문자열이 메모리에 저장되는 구조

* 문자의 마지막을 표현하기 위해 문자열의 마지막에 '\0' - ASCII Code NULL 이 저장됨



```c
#include <stdio.h>

int main()
{
    int a = 1;
    int int_arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    printf("%i %i %i\n", int_arr[0], int_arr[1], int_arr[9]);
    printf("%i\n", int_arr[10]);
  
//    printf("%i\n", int_arr[10000]);
  
    return 0;
}
```

* ```c
  printf("%i\n", int_arr[10]);
  // 1164378127
  ```

  * 배열의 범위 (0~9) 를 넘어간 위치이기 때문에, 임의의 숫자가 할당 되어 있음을 확인

* ```c
  printf("%i\n", int_arr[10000]);
  // Error 발생: EXC_BAD_ACCESS
  ```

  * 배열의 범위를 크게 벗어났기 때문에 에러 발생



```c
#include <stdio.h>

int main()
{
    char c = 'a';
    char str1[10] = "Hello";
    char str2[10] = {'H','i'};
    
    printf("%c\n", c);
    printf("%s\n", str1);
    printf("%s\n", str2);
    
    printf("%hhi %hhi %hhi %hhi %hhi\n", str2[0], str2[1], str2[2], str2[3], str2[4]);
    
//    char str3[10] = "Hello, World"; // array size is not enough
    char str3[20] = "Hello, \0World";
    printf("%s\n", str3);
//    NULL을 만나서, Hello 까지만 printf가 동작
    return 0;
}
```

* ```c
  printf("%hhi %hhi %hhi %hhi %hhi\n", str2[0], str2[1], str2[2], str2[3], str2[4]);
  // 72 105 0 0 0
  ```

  * ASCII 코드 숫자를 출력하였을때, 문자열의 빈 공간에 0이 할당되어 있는것을 확인 할 수 있음.

* ```c
  char str3[10] = "Hello, World";
  printf("%s\n", str3);
  // Hello, Wor\240
  ```

  * array size is not enough
  * NULL character 까지 합쳐 13 글자를 10칸의 메모리에 할당 하게 되어, 10개의 글자 까지만 배열에 저장
  * 배열에 NULL이 없기 때문에 printf 함수는 계속 동작하여 NULL 을 만날때까지 메모리에 임의 저장된 값들을 출력

* ```c
  char str3[20] = "Hello, \0World";
  printf("%s\n", str3);
  // Hello,
  ```

  * NULL을 만나면 pirntf 함수가 정지되어 이전까지만 출력 됨

