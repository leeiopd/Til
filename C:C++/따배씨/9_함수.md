# 따배씨 - 따라하며 배우는 C언어

# 9강 함수

##### 9.1 함수가 필요할 때

```c
#include <stdio.h>

int main(){
    printf("********************\n");
    printf("        LEE\n");
    printf("    Seoul, Korea\n");
    printf("********************\n");
  
  	return 0;
}
```



```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define WIDTH 20
#define NAME "LEE"
#define ADDRESS "Seoul, Korea"

void print_multiple_chars(char c, int n_stars, bool print_newline);
void print_centered_string(char str[]);

int main(){

    print_multiple_chars('*', WIDTH, true);
    print_centered_string(NAME);
    print_centered_string(ADDRESS);
    print_multiple_chars('*', WIDTH, true);
    
    
    return 0;
}

void print_multiple_chars(char c, int n, bool print_newline){
    
    for (int i = 0; i < n; ++i){
        printf("%c", c);
    }
    
    if (endl)
        printf("\n");
}

void print_centered_string(char str[])
{
    int n_blanks = 0;
    n_blanks = (int)(WIDTH - strlen(str)) / 2;
    print_multiple_chars(' ', n_blanks, false);
    printf("%s\n", str);
}
```



##### 9.2 함수의 프로토 타입

* 모든 함수의 내부동작을 외울수 없음
  * 블랙박스로서의 함수, 입력과 출력만 생각하고 전체 구조를 작성

* 컴퓨터가 Compile 을 할 때, 블랙박스로서 동작만 알면 됨
  * prototype 형태만 있으면 Compile이 진행 됨
  * Compile 만 진행되고, 실행파일을 만드는 Linking은 진행되지 않음
    * Linking 단계에서 함수의 실행 내용이 없기 때문



* ```c
  void print_multiple_chars(char c, int n_stars, bool print_newline);
  ```

  * 함수의 prototype 선언
  * void: 함수의 실행 결과 값의 자료형
  * print_multiple_chars: 함수 명
  * (char c, int n_stars, bool print_newline) : 매개변수, Parameter

*  ```c
  print_multiple_chars('*', WIDTH, true);
  ```

  * 함수 호출
  * ('*', WIDTH, true): argument, 함수의 입력값

* ```c
  void print_multiple_chars(char c, int n, bool print_newline){
      
      for (int i = 0; i < n; ++i){
          printf("%c", c);
      }
      
      if (endl)
          printf("\n");
  }
  ```

  * 함수의 선언문
  * 함수의 형이 void 이기 때문에, return 값이 생략

* ```c
  void print_multiple_chars(char, int, bool);
  ...
  void print_multiple_chars(char c, int n, bool print_newline){
      
      for (int i = 0; i < n; ++i){
          printf("%c", c);
      }
      
      if (endl)
          printf("\n");
  }
  ```

  * prototype 선언에서는 매개변수 형 까지만 입력하고 함수 선언부에서 매개변수 명까지 입력해도 complie이 된다
    * 블랙박스 모델에서 프로토타입 선언은 데이터 타입의 입력/출력만 중요하기 때문
    * 그래도 작성하는것이 좋다



##### 9.3 함수의 자료형과 반환값

```c
#include <stdio.h>

int int_min(int, int);

int main(){
    int i1, i2;
    
    while(1)
    {
        printf("Input two integers: ");
        
        if (scanf("%d %d", &i1, &i2) != 2)break;
        
        int lesser = int_min(i1, i2);
        // int lesser = min
        
        printf("The lesser of %d and %d is %d\n", i1, i2, lesser);
    }
    
    printf("End.\n");
}

int int_min(int i1, int i2)
{
    return (i1 < i2)? i1: i2;
}
```

* ```c
  int int_min(int i1, int i2)
  {
      return (float)i1
  }
  ```

  * float 을 int 로 형 변환하는 과정에서 Error 가 발생한다고 알려줌
    * 함수의 return 타입이 int 이기 때문에 (int)(float)i1 이 되기때문에, Error가 발생하는것



##### 9.4 변수의 영역 Scope 와 지역 변수 Local Variable

* 변수는 변수를 사용 할수 있는, 유효한 영역이 존재
  * 변수의 유효한 범위는 { } 안의 영역임, 지역 변수

* 더 큰 영역의 변수를, 그 안의 더 작은 영역에서 새로 선언 하게 된다면 새로운 변수가 됨
* 작은영역의 변수는 더 큰 영역에서 사용 불가, 볼 수 없음
  * invisible



```c
#include <stdio.h>

int int_max(int i, int j);

int main(){
    int a;
    
    a = int_max(1, 2);
    
    printf("%d\n", a);
    printf("%p\n", &a);
    
    {
        a = int_max(4, 5);
        
        printf("%d\n", a);
        printf("%p\n", &a);
    }
}

int int_max(int i, int j)
{
    int m;
    m = (i > j) ? i : j;
    return m;
}
```

* ```c
  printf("%p\n", &a);
  ```

  * 주소값 직접 출력

* 출력되는 모든 주소값이 똑같은것을 확인 할수 있음

  * 같은 주소 == 같은 변수



```c
#include <stdio.h>

int int_max(int i, int j);

int main(){
    int a;
    
    a = int_max(1, 2);
    
    printf("%d\n", a);
    printf("%p\n", &a);
    
    {
        int a;
        a = int_max(4, 5);
        
        printf("%d\n", a);
        printf("%p\n", &a);
    }
    
    printf("%d\n", a);
    printf("%p\n", &a);
}

int int_max(int i, int j)
{
    int m;
    m = (i > j) ? i : j;
    return m;
}

```

* 출력되는 주소값 중, 새로운 영역 { } 안의 주소값만 다른것을 확인
  * 새로운 영역안에서 지역 변수로 선언한 변수는 새 메모리 주소가 할당 되는 새로운 변수



##### 9.5 지역 변수와 스택 Stack

* 최신 컴파일러는 여러가지 최적화 기술을 사용하기 때문에, 변수의 메모리 주소가 고정 되기도 함

![9_5_1_스택](imgs/9_5_1_스택.png)

* 프로그램이 진행됨에 따른 stack의 변화
* stack 메모리에 존재하는 변수는 어디서든 직접 접근해서 사용 가능



##### 9.6 재귀 호출 Recursion

* 함수가 자기 자신을 호출하는 함수

```c
#include <stdio.h>

void my_func(int);

int main(){
    my_func(1);
    
    return 0;
}

void my_func(int n){
    printf("Level %d, address of variable n = %p\n", n, &n);
    
    my_func(n + 1);
}
```

* 출력 결과

  ```*ㅊ
  Level 1, address of variable n = 0x7ffeefbff46c
  Level 2, address of variable n = 0x7ffeefbff44c
  Level 3, address of variable n = 0x7ffeefbff42c
  Level 4, address of variable n = 0x7ffeefbff40c
  Level 5, address of variable n = 0x7ffeefbff3ec
  .....
  무한 호출
  ```
  * 메모리 주소의 차이가 크게 남
    * 프로그램이 호출 될 때 마다, stack 메모리에 변수 뿐만 아니라 프로그램도 쌓이게 됨
    * 재귀호출로 stack 에 큰 부담이 갈 수 있음
    * stack 메모리가 가득 차면, stack overflow error 발생



* 재귀호출은 무한루프 구현을 위해 사용하지 않음
  * 재귀 호출의 조건을 걸어주어서 구현해야함

```c
#include <stdio.h>

void my_func(int);

int main(){
    my_func(1);
    
    return 0;
}

void my_func(int n){
    
    printf("Level %d, address of variable n = %p\n", n, &n);
    
    if (n < 4)
        my_func(n + 1);
}
```

* 4번 호출되고 종료



##### 9.7 재귀호출 Recursion 과 스택 Stack

 ```c
#include <stdio.h>

void my_func(int);


int main(){
    my_func(1);
    
    return 0;
}

void my_func(int n){
    
    printf("Level %d, address of variable n = %p\n", n, &n);
    
    if (n < 4)
        my_func(n + 1);
    
    printf("Level %d, address of variable n = %p\n", n, &n);
}
 ```

* 출력 결과

  ```c
  Level 1, address of variable n = 0x7ffeefbff46c
  Level 2, address of variable n = 0x7ffeefbff44c
  Level 3, address of variable n = 0x7ffeefbff42c
  Level 4, address of variable n = 0x7ffeefbff40c
  Level 4, address of variable n = 0x7ffeefbff40c
  Level 3, address of variable n = 0x7ffeefbff42c
  Level 2, address of variable n = 0x7ffeefbff44c
  Level 1, address of variable n = 0x7ffeefbff46c
  ```

  * level 이 같을 때, n 의 주소값은 같음



![9_7_1_재귀함수와 스택](imgs/9_7_1_재귀함수와 스택.png)

* 재귀함수의 호출에서의 stack
* 재귀함수의 호출 시 변수 메모리 공간 뿐만 아니라, 함수가 동작하기 위한 공간도 같이 stack 에 쌓임
  * stack frame



##### 9.8 팩토리얼 Factorial 예제

```c
#include <stdio.h>

long loop_factorial(int n);
long recursive_factorial(int n);

int main(){
    int num = 5;
    
    printf("%ld\n", loop_factorial(num));
    printf("%ld\n", recursive_factorial(num));
    
    return 0;
}

long loop_factorial(int n){
    long result;
    
    for (result = 1; n > 1; n--){
        result *= n;
    }

    return result;
}

long recursive_factorial(int n){
    if (n <= 0){
        return 1;
    }
    
    return n * recursive_factorial(n-1);
}
```

* ```c
  return n * recursive_factorial(n-1);
  ```

  * tail(end) recursion: return 에서 재귀 호출 하는 구조



##### 9.9 이진수 변환 예제

```c
#include <stdio.h>

void print_binary(unsigned long n);
void pirnt_binary_loop(unsigned long n);

int main(){
    unsigned long num  = 10;
    
    pirnt_binary_loop(num);
    print_binary(num);
    
    printf("\n");
    
    return 0;
}

void pirnt_binary_loop(unsigned long num){
    
    while(1){
        unsigned long quotient = num / 2;
        unsigned long remainder = num % 2;
        
        printf("%ld", remainder);
        
        num = quotient;
        
        if (num == 0) break;
    }
    printf("\n");
}

void print_binary(unsigned long num){
    int remainder = num % 2;
    
    if (num >= 2)
        print_binary(num / 2);
    
    printf("%d", remainder);
    
    return;
}
```



