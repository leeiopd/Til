# 따배씨 - 따라하며 배우는 C언어

### 15강 비트 다루기

##### 15.1 비트단위 Bitwise 논리 연산자 Logical Operators

* Regular Logical Operators : &&, ||, and !

  ```c
  bool have_apple = true;
  bool like_apple = true;
  
  if (have_apple && like_apple)
    	eat_apple();
  ```

* Bitwise Logical Operators
  * Bitwise NOT: ~ (Tilde)
    * ~1 = 0
    * ~0 = 1
  * Bitwise AND: & (Ampersand)
    * 1&1 = 1
    * 1&0 = 0
    * 0&1 = 0
    * 0&0 = 0
  * Bitwise OR: | (Vertical bar)
    * 1|1 = 1
    * 1|0 = 1
    * 0|1 = 1
    * 0|0 = 0
  * Bitwise EXCLUSIVE OR: ^ (Caret)
    * 1 ^ 1 = 0
    * 1 ^ 0 = 1
    * 0 ^ 1 = 1
    * 0 ^ 0 = 0



* 가장 작은 자료형인 char 를 사용하더라도 8개의 자료를 표기하려면 8bytes == 64bits 가 필요함
  * bit 연산자를 사용하면 8bit 로 표현 가능



##### 15.2 이진수를 십진수로 바꾸기 연습문제

```c
#include <stdio.h>
#include <math.h>   // pow()
#include <string.h> // strlen()
#include <stdlib.h> // exit()

unsigned int to_decimal(const char bi[]);

int main()
{
    printf("Binary (string) to Decimal conversion\n");
    
    printf("%d\n", to_decimal("00000110"));
    printf("%d\n", to_decimal("00010110"));
    
    printf("%d\n", to_decimal("10010100"));
    
    return 0;
}

unsigned int to_decimal(const char bi[]) // unsigned char 범위 0~255
{
    const size_t bits = strlen(bi);
    // size_t : 시스템에서 값이 포함 할 수 있는 최대 크기의 데이터를 표현하는 타입
    
    unsigned int sum = 0;
    for (size_t i = 0; i < bits; i++)
    {
        if (bi[i] == '1')
            sum += (int)pow(2, bits - 1 - i);
        else if(bi[i] != '0')
        {
            printf("Wrong character : %c", bi[i]);
            exit(1);
        }
    }
    
    
    return sum;
}
```



##### 15.3 &를 이용하는 십진수 -> 이진수 연습 문제

```c
#include <stdio.h>
#include <math.h>   // pow()
#include <string.h> // strlen()
#include <stdlib.h> // exit()
#include <stdbool.h>

unsigned char to_decimal(const char bi[]);
void print_binary(const unsigned char num);

int main()
{
    unsigned char i = to_decimal("01000110");
    unsigned char mask = to_decimal("00000101");
    
    print_binary(i);
  	// Decimal  70 	== Bianry 01000110
    print_binary(mask);
  	// Decimal   5 	== Bianry 00000101
    print_binary(i & mask);
  	// Decimal   4 	== Bianry 00000100
    
    return 0;
}


unsigned char to_decimal(const char bi[])
{
    const size_t L = strlen(bi);
    unsigned sum = 0;
    for (size_t i = 0; i < L; i++)
    {
        if (bi[i] == '1')
            sum += (int)pow(2, L - 1 - i);
    }
    
    return sum;
}


void print_binary(const unsigned char num)
{
    printf("Decimal %3d \t== Bianry ", num);
    
    const size_t bits = sizeof(num) * 8;
    
    for (size_t i = 0; i < bits; i++)
    {
        const unsigned char mask = (unsigned char)pow((double)2, (double)(bits - 1 - i));
        
        if ((num & mask) == mask)
            // 2진 수의 자리수를 검사하는 mask 변수를 만들어 이진수의 자리수 bit 연산
            printf("%d", 1);
        else
            printf("%d", 0);
    }
    printf("\n");
    
}
```



##### 15.4 비트 단위 논리 연산자 확인해보기

```c
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>

unsigned char to_decimal(const char bi[]);
void print_binary(const unsigned char num);

int main()
{
    /*
        Regular Logical Operators : &&, ||, and !
     
        bool have_apple = true;
        bool like_apple = true;
        if (have_apple && like_apple)
            eat_apple();
     
        Bitwise Logical Operators :
            - Bitwise NOT ~
            - Bitwise AND &
            - Bitwise OR |
            - Bitwise EXCLUSIVE OR ^
     */
    
    unsigned char a = 6;
    unsigned char b = 5;
    
    printf("%hhu\n", a);
    print_binary(a);
  	// 6
		// Decimal   6 	== Bianry 00000110
    
    printf("%hhu\n", b);
    print_binary(b);
  	// 5
		// Decimal   5 	== Bianry 00000101
    
    printf("%hhu\n", a & b);
    print_binary(a & b);
  	// 4
		// Decimal   4 	== Bianry 00000100
    
    printf("%hhu\n", a | b);
    print_binary(a | b);
  	// 7
		// Decimal   7 	== Bianry 00000111
    
    printf("%hhu\n", a ^ b);
    print_binary(a ^ b);
  	// 3
		// Decimal   3 	== Bianry 00000011
    
    printf("%hhu\n", ~a);
    print_binary(~a);
  	// 249
		// Decimal 249 	== Bianry 11111001
    
    return  0;
}

unsigned char to_decimal(const char bi[])
{
    const size_t L = strlen(bi);
    unsigned char sum = 0;
    for (size_t i = 0; i < L; i++)
    {
        if (bi[i] == '1')
            sum += (int)pow(2, L - 1 - i);
    }
    
    return sum;
}


void print_binary(const unsigned char num)
{
    printf("Decimal %3d \t== Bianry ", num);
    
    const size_t bits = sizeof(num) * 8;
    
    for (size_t i = 0; i < bits; i++)
    {
        const unsigned char mask = (unsigned char)pow((double)2, (double)(bits - 1 - i));
        
        if ((num & mask) == mask)
            // 2진 수의 자리수를 검사하는 mask 변수를 만들어 이진수의 자리수 bit 연산
            printf("%d", 1);
        else
            printf("%d", 0);
    }
    printf("\n");
}
```



##### 15.5 2의 보수 2's Complement 표현법 확인해보기

```c
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>


void print_binary(const char num);
int main()
{
    /*
        Signed Integers
     
        - Sign-magnitude representation
        00000001 is 1 and 10000001 is -1
        00000000 is +0, 10000000 is -0
        Two zeros +0, -0, from -127 to +127
     
        - One's complement method
        To reverse the sign, invert each bit.
        00000001 is 1 and 11111110 is -1.
        11111111 is -0
        from -127 to +127
     */
    
    print_binary(127);
  	// Decimal 127 	== Bianry 01111111
    print_binary(-127);
  	// Decimal -127 	== Bianry 10000001
    print_binary(~127 + 1);
  	// Decimal -127 	== Bianry 10000001
  
    print_binary(12);
  	// Decimal  12 	== Bianry 00001100
    print_binary(-12);
  	// Decimal -12 	== Bianry 11110100
    print_binary(~12 + 1);
  	// Decimal -12 	== Bianry 11110100
    
    return  0;
}

void print_binary(const char num)
{
    printf("Decimal %3d \t== Bianry ", num);
    
    const size_t bits = sizeof(num) * 8;
    
    for (size_t i = 0; i < bits; i++)
    {
        const char mask = (char)pow((double)2, (double)(bits - 1 - i));
        
        if ((num & mask) == mask)
            printf("%d", 1);
        else
            printf("%d", 0);
    }
    printf("\n");
    
}
```



##### 15.6 비트단위 쉬프트 Shift 연산자

```c
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>


void int_binary(const int num);
int main()
{
    /*
        Bitwise shift operators
     
        - Left shift
        number << n : multiply number by 2^n
     
        - Right shift
        number >> n : divede by 2^n (for non-negative numbers)
     */
    
    // 8 bit integer cases
    //
    
    printf("%hhd\n", 1 << 3);
  	// 00000001 -> 00000001??? -> 00001000
  	// 8
  
    printf("%hhd\n", 8 >> 1);
  	// 00001000 -> ?00001000 -> 00000100
    // 4
  
    printf("%hhd\n", -119 >> 3);
  	// 10001001 -> ???10001001 -> 11110001
  	// -15
      
    printf("%hhd\n", -119 << 4);
  	// 10001001 -> 10001001???? -> 10010000
  	// -112
    
    // unsigned
    printf("%hhd\n", 137 >> 3);
  	// 10001001 -> ???10001001 -> 00010001
  	// 17
  
    printf("%hhd\n", 137 << 4);
  	// 10001001 -> 10001001???? -> 10010000
  	// -112
    
    
    // singed 인 경우 right shift 의 경우 기계마다 다르지만, 주로 1로 채우게 됨
    
    int a = 1;
    
    a <<= 3;
    a >>= 2;
    
    printf("Unsigned int %u\n", 0xffffffff);
    // Unsigned int 4294967295
    printf("Signed int %d\n", 0xffffffff);
    // Signed int -1
    
    int_binary(0xffffffff);
  	// Decimal  -1 	== Bianry 11111111111111111111111111111111
    
    printf("Right shift by 3\n");
  	// Right shift by 3
    int_binary((signed)0xffffffff >> 3);
  	// Decimal  -1 	== Bianry 11111111111111111111111111111111
    int_binary((unsigned)0xffffffff >> 3);
  	// Decimal  -1 	== Bianry 11111111111111111111111111111111
    
    printf("\nUnsigned int %u\n", 0x00ffffff);
  	// Unsigned int 16777215
    int_binary(0x00ffffff);
  	// Decimal 16777215 	== Bianry 00000000111111111111111111111111
    
    printf("Right shift by 3\n");
  	// Right shift by 3
    int_binary((signed)0x00ffffff >> 3);
  	// Decimal 2097151 	== Bianry 00000000000111111111111111111111
    int_binary((unsigned)0x00ffffff >> 3);
  	// Decimal 2097151 	== Bianry 00000000000111111111111111111111

    return  0;
}

void int_binary(const int num)
{
    printf("Decimal %3d \t== Bianry ", num);
    
    const size_t bits = sizeof(num) * 8;
    
    for (size_t i = 0; i < bits; i++)
    {
        const int mask = 1 << (bits - 1 - i);
        // bit 연산자를 이용하여 mask 를 만듬, 더 효율적
        
        if ((num & mask) == mask)
            printf("%d", 1);
        else
            printf("%d", 0);
    }
    printf("\n");
}
```