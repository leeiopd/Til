# 따배씨 - 따라하며 배우는 C언어

### 10강 배열과 포인터

##### 10.1 배열과 메모리

![10_1_1_배열과 메모리](./imgs/10_1_1_배열과 메모리.png)

![10_1_2_배열과 메모리2](./imgs/10_1_2_배열과 메모리2.png)

* Array 선언 시, 연속된 메모리 공간을 할당 받게 됨

* Array 의 index 는 0 부터 시작

  * ```c
    int arr[4] = {2, 5, 11, 18};
    ```

    * arr = &arr[0]

  * arr 가 할당 된 모든 주소값에 첫번째 주소값을 빼주고, 각 주소값에 할당된 size를 나누면 index number 가 나옴

    * ![10_1_3_배열의 인덱스 넘버1](./imgs/10_1_3_배열의 인덱스 넘버1.png)
    * ![10_1_4_배열의 인덱스 넘버2](./imgs/10_1_4_배열의 인덱스 넘버2.png)
    * ![10_1_5_배열의 인덱스 넘버3](./imgs/10_1_5_배열의 인덱스 넘버3.png)



##### 10.2 배열의 기본적인 사용 방법

```c
#include <stdio.h>

#define MONTHS 12   // symbolic constant, mecro

int main(){
    int high[MONTHS] = {2, 5, 11, 18, 23, 27, 29, 30, 26, 20, 12, 24};
    
    for (int i = 0; i < MONTHS; ++i)
        printf("%d ", high[i]);
    printf("\n");
    
    float avg = 0.0;
    for (int i = 0; i < MONTHS; ++i)
        avg += high[i];
    
    printf("Average = %f\n", avg / (float)MONTHS);
    
    return 0;
}
```



```c
#include <stdio.h>

#define MONTHS 12   // symbolic constant, mecro

int main(){
    int high[MONTHS] = {2, 5, 11, 18, 23, 27, 29, 30, 26, 20, 12, 24};
    
    printf("%p %p\n", high, &high[0]);
  	// 0x7ffeefbff450 0x7ffeefbff450
    
	  return 0;
}
```

* Array 의 주소와, Array[0] 의 주소값이 같은것을 확인



```c
#include <stdio.h>

#define MONTHS 12   // symbolic constant, mecro

int main(){
    int high[MONTHS] = {2, 5, 11, 18, 23, 27, 29, 30, 26, 20, 12, 24};
  
    for (int i = 0; i < MONTHS; ++i)
        printf("%lld\n", (long long)&high[i]);
  	// 140732920755280
  	// 140732920755284
  	// 140732920755288
  	// 140732920755292
  	// 140732920755296
  	// 140732920755300
  	// 140732920755304
  	// 140732920755308
  	// 140732920755312
  	// 140732920755316
  	// 140732920755320
  	// 140732920755324
 
    return 0;
}

```

* Array의 index간 메모리 주소 차이가 4 인것을 확인
  * 4 byte integer 를 저장하는 Array를 선언하였기 때문



```c
#include <stdio.h>

#define MONTHS 12   // symbolic constant, mecro

int main(){
    int high[MONTHS] = {2, 5, 11, 18, 23, 27, 29, 30, 26, 20, 12, 24};
    
    high[12] = 4;
    high[-1] = 123;
    
    printf("%d %d\n", high[12], high[-1]);
    return 0;
}
```

* Array 의 indexing number 가 범위를 넘어났지만, warning이 발생하고 build가 진행
  * Debug 에서는 메몰 공간을 많이 제공하기 때문에 문제가 발생하지 않지만
  * Release 에서는 오류가 나거나 정상적으로 수행이 되지 않을 수 있음, 주의



```c
#include <stdio.h>

#define MONTHS 12   // symbolic constant, mecro

int main(){
    int not_init[4];
    
    for (int i = 0; i < 4; i++)
        printf("%d\n", not_init[i]);
    
    return 0;
}
```

* 초기화를 하지 않으면, 기본적으로 쓰레기 값이 들어감

  * xcode 의 경우 0으로 초기화

  * ```c
    static int not_init[4];
    ```

    * static 으로 선언 해주어도 0으로 초기화, Storage class



```c
#include <stdio.h>

#define MONTHS 12   // symbolic constant, mecro

int main(){
    int insfuu[4] = {2, 4};
    
    for (int i = 0; i < 4; i++)
        printf("%d", not_init[i]);
    // 2 4 0 0
    return 0;
}
```

* 일부만 초기화 해주었을때는, compiler 가 나머지 부분 0 으로 초기화



```c
#include <stdio.h>

int main(){
    const int power_of_twos[] = {1, 2, 4, 8};
    
    printf("%lu\n", sizeof(power_of_twos));
  	// 16
  
    printf("%lu\n", sizeof(int));
  	// 4
    printf("%lu\n", sizeof(power_of_twos[0]));
  	// 4
    
    for (int i = 0; i < sizeof power_of_twos / sizeof power_of_twos[0]; ++i)
        printf("%d ", power_of_twos[i]);
    
    printf("\n");
    return 0;
}
```

* A rray 의 크기를 정하지 않고 초기화 하였을때, 사용하는 방법
  * Compiler 가 배열의 크기를 초기화 한 것 처럼 처리
  * 동적 할당에서는 이 방법으로 사용 불가, Array 에서만 사용 가능



```c
#include <stdio.h>

#define MONTH 12

int main(){
    int days[MONTH] = {31, 28, [4] = 31, 30, 31, [1] = 29};
    for (int i = 0; i < MONTH; ++i)
        printf("%d ", days[i]);
    // 31 29 0 0 31 30 31 0 0 0 0 0 
  
    printf("\n");
    return 0;
}
```

* Designated initializers: 초기화 값을 index로  지정

  * ```c
    int days[MONTH] = {31, 28, [4] = 31, 30, 31, [1] = 29};
    ```

  * days[4] = 31, days[1] = 29



##### 10.3 포인터의 산술 연산 Pointer Arithmetic

```c
#include <stdio.h>

int main(){
    int* ptr = 0;
    
    printf("%p %lld\n", ptr, (long long)ptr);
    // 0x0 0
  
    ptr ++;
    
    printf("%p %lld\n", ptr, (long long)ptr);
  	// 0x4 4
    
    return 0;
}
```

* 주소값에 1 을 더하면, 다음 주소값이 나옴
  * 다음 주소값: 자료형에 할당되는 메모리크기 만큼의 역역 뒤의 주소값
  * int -> +4
  * char -> +1
  * void는 산술연산 불가, 자료형이 없기 때문
* 뺄셈도 마찬가지로 빼기 동작



```c
#include <stdio.h>

int main(){
    int arr[10];
    int* ptr1 = &arr[3], * ptr2 = &arr[5];
    
//    int ptr_add = ptr1 + ptr2;
    
    int ptr_sub = ptr2 - ptr1;
    
    
    return 0;
}
```

* 주소값의 합, Error, 불가능
* 주소값의 차, 배열 안에서의 index 차, 가능



##### 10.4 포인터 Pointer 와 배열 Array

```c
#include <stdio.h>

int main(){
    int arr[10];
    
    int num = sizeof(arr) / sizeof(arr[0]);
    for (int i = 0; i < num; ++i){
        arr[i] = (i+1) * 100;
    }
    
    int * ptr = arr;
    
    printf("%p %p %p\n", ptr, arr, &arr[0]);
    // 0x7ffeefbff410 0x7ffeefbff410 0x7ffeefbff410

    ptr += 2;
    // arr += 2 // invalid
    
    printf("%p %p %p\n", ptr, arr+2, &arr[2]);
    // 0x7ffeefbff418 0x7ffeefbff418 0x7ffeefbff418

    printf("%d %d %d\n", *(ptr+1), *(arr+3), arr[3]);
  	// 400 400 400
    return 0;
}
```



```c
#include <stdio.h>

int main(){
    int arr[10];
    int num = sizeof(arr) / sizeof(arr[0]);
    
    for (int i = 0; i < num; ++i){
            arr[i] = (i+1) * 100;
        }
    
    int* ptr = arr;
    
    for (int i = 0; i < num; i++){
        printf("%d %d\n", *ptr, arr[i]);
        ptr++;
    }
    return 0;
}
```

* ```c
  for (int i = 0; i < num; i++){
          printf("%d %d\n", *ptr, arr[i]);
          ptr++;
      }
  ```

  * ```c
    for (int i = 0; i < num; i++){
            printf("%d %d\n", *(ptr+i), arr[i]);
        }
    ```

    * 같은 결과, 성능차이가 거의 없음  // 이전에는 후위연산자가 빨랐음



##### 10.5 2차원 배열과 메모리

* 2차원 배열도 메모리는 1차원

![10_5_1_이차원배열](imgs/10_5_1_이차원배열.png)



```c
#include <stdio.h>

int main(){
    int arr[2][3] = { {1, 2, 3},
                      {4, 5, 6}};
    
    printf("%d\n\n", arr[1][1]);
    
    for (int j = 0; j < 2; ++j){
        for (int i = 0; i < 3; ++i){
            printf("%d ", arr[j][i]);
        }
        
        printf("\n");
    }
    return 0;
}
```

* 배열의 값을 호출 할때, 메모리 구조 같은 순서로 호출하면 성능상 이득이 있음



```c
#include <stdio.h>

int main(){
    int arr[2][3] = { {1, 2, 3},
                      {4, 5, 6}};
    
    int *ptr = &arr[0][0];
    
    for (int i = 0; i < 6; ++i)
        printf("%d ", ptr[i]);
    printf("\n");
    return 0;
}
```

* 2 차원 배열을, 메모리 주소를 이용하여 1차원 배열처럼 호출 가능



```c
#include <stdio.h>

int main(){
    int arr[2][3] = { {1, 2, 3},
                      {4, 5, 6}};
    
    printf("%zd %zd\n", sizeof(arr), sizeof(arr[0]));
  	// 24 12
    
    return 0;
}

```



##### 10.6 2차원 배열 연습문제

```c
#include <stdio.h>

#define MONTH 12
#define YEARS 3

int main(){
//    double years2016[MONTH] = { -3.2, 0.2, 7.0, 14.1, 19.6, 23.6, 26.2, 28.0, 23.1, 16.1, 6.8, 1.2};
//    double years2017[MONTH] = {-1.8, -0.2, 6.3, 13.9, 19.5, 23.3, 26.9, 25.9, 22.1, 16.4, 5.6, -1.9};
//    double years2018[MONTH] = {-4.0, -1.6, 8.1, 13.0, 18.2, 23.1, 27.8, 28.8, 21.5, 13.1, 7.8, -0.6};
    
    double years_temp_datas[YEARS][MONTH] = {
        { -3.2, 0.2, 7.0, 14.1, 19.6, 23.6, 26.2, 28.0, 23.1, 16.1, 6.8, 1.2},
        {-1.8, -0.2, 6.3, 13.9, 19.5, 23.3, 26.9, 25.9, 22.1, 16.4, 5.6, -1.9},
        {-4.0, -1.6, 8.1, 13.0, 18.2, 23.1, 27.8, 28.8, 21.5, 13.1, 7.8, -0.6}
    };
    
    printf("[Temperature Data]\n");
    
    printf("year index  :");
    for (int j = 0; j <= MONTH; ++j){
        printf("\t%d", j+1);
    }
    printf("\n");
    
    for (int j = 0; j < YEARS; ++j){
        printf("year %d     :", j);
        for (int i = 0; i < MONTH; ++i){
            printf("\t%.1f", years_temp_datas[j][i]);
        }
        printf("\n");
    }
    printf("\n");
    
    printf("[Yearly average temperatures of 3 years]\n");
    for (int j = 0; j < YEARS; ++j){
        double avg_tmp = 0.0;
        
        for (int i = 0; i < MONTH; ++i){
            avg_tmp += years_temp_datas[j][i];
        }
        
        avg_tmp /= (double)MONTH;
        
        printf("Year %d : average temperature = %.1f\n", j, avg_tmp);
    }
    printf("\n");
    
    printf("[Montly average temperatures for 3 years]\n");
    printf("Year index : ");
    for (int i = 0; i < MONTH; ++i){
        printf("\t%d", i+1);
    }
    printf("\n");
    
    printf("Avg temp    : ");
    for (int i = 0; i < MONTH; ++i){
        double avg_tmp = 0;
        for (int j = 0; j < YEARS; ++j){
            avg_tmp += years_temp_datas[j][i];
        }
        avg_tmp /= (double)YEARS;
        printf("\t%.1f ", avg_tmp);
    }
    printf("\n");
    
    return 0;
}
```



##### 10.7 배열을 함수에게 전달해주는 방법

* 배열을 여러 함수에게 사용할 때 마다, 데이터를 복사 해주는 방식은 굉장히 비효율적
  * 배열의 첫 주소를 알려주는 방식으로 해결
* 함수에서 배열을 입력 받을때, 내부적으로 pointer 로 받아 처리
  * c/c++ 의 프로그래밍 에서는 크기가 미리 정해진 배열보다는 동적할당 메모리를 배열처럼 이용하는것이 주 사용 하는 방법
  * 동적할당 메모리를 사용 할때에는 pointer 를 이용함



```c
#include <stdio.h>

double averge(double arr[], int n);

int main(){
    double arr1[5] = {10, 13, 12, 7, 8};
    double arr2[5] = {1.8, -0.2, 6.3, 13.9, 20.5};
    
    printf("Avg = %f\n", averge(arr1, sizeof(arr1)/ sizeof(double)));
  	// Avg = 10.000000
  
    printf("Avg = %f\n", averge(arr2, sizeof(arr2)/ sizeof(double)));
  	// Avg = 8.460000
     
    return 0;
}


double averge(double arr[], int n){
    double avg = 0.0;
    for (int i = 0; i < 5; i++){
        avg += arr[i];
    }
    
    avg /= (double)n;
    
    return avg;
}
```

* ```c
  double averge(double arr[], int n);
  ```

  * 배열을 함수에 입력 값으로 받기 위해서는, 배열 값과 함께 배열의 크기를 받아 준다

  * prototype 표기 방법

    * ```c
      double averge(double arr[], int n);
      ```

    * ```c
      double averge(double* arr, int n);
      ```

    * ```c
      double averge(double* , int n);
      ```

    * ```c
      double averge(double [], int n);
      ```





