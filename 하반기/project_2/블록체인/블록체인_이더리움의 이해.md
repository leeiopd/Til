# 블록체인



## 이더리움의 이해



### 1. 이더리움 소개

> 이더리움

* 2013년, Vitalik Buterin이 제안한 공개형 블록체인
  * 2014년 crowcl sale 실시
  * 2015년 6월 동작 시작
* 분산 어플리케이션을 위한 플랫폼을 표방
* Blockchain 2.0
  * 비트코인의 scripting language를 개선, 발전시킨 스마트 컨트랙트 도입
  * 이후 등장한 블록체인들이 스마트 컨트랙트를 핵심요소로 지고 있음
* 이더(Ether, ETH)
  * 이더리움에서 발행한 암호화폐
  * 거래(Transaction), 스마트 컨트랙트 비용(Gas) 지불 등으로 동작


* 분산화된 상태전이 머신
  * 트랜젝션에 기반한 상태전이
    * 단, 이전 상태로 되돌아갈 수 없음
  * 암호화 암고리즘을 활용 -> 무작위로 상태전이가 일어나는 것을 방지
  * 모든 참여자가 동일한 상태를 공유
  * 블록은 해당 시점의 이더리움을 상태를 나타낸다고 불 수 있음
    * 현재 블록 -> 현재 이더리움의 상태



> 이더리움의 구성요소

* 계정

  * 외부 소유 계정(EOA, External Owned Account)
    * ETH 잔액 유지
    * 개인 키를 통한 주소 관리
    * ETH 전송, 컨트랙트 실행을 위한 거래 전송 가능
    * 컨트랙트 코드를 가지고 있지 않음(빈 문자열 hash값)
  * 컨트랙트 계정(CA, Contract Account)
    * ETH 잔액 유지
    * 주소를 가지고 있으나 개인키는 존재하지 않음
    * 컨트랙트 코드를 보유
    * 거래나 메시지를 수신하면 보유하고 있는 컨트랙트 코드를 실행

* 주소 생성

  1. 개인키 생성 : 256bit의 무작위 숫자 -> 64자리의 HEX값으로 인코딩
  2. 타원곡선전사서명 알고리즘(ECDSA, secp256k1)을 사용하여 공개키 생성
  3. Keccak-256 hashing
  4. 계정 주소

* 상태

  * 어느 한 시점에 대한 Ether의 잔액, 기타 정보를 담고 있는 계정(Account)들의 집합
  * 모든 이더리움의 참여 노드는 로컬에 상태 정보를 유지함
  * stateObject
    * 상태의 수정이 발생한 이더리움 계정을 나타내는 객체
    * 주요 데이터
      * 이더리움의 주소
      * 이더리움 주소의 hash값
      * 이더리움 계정
      * 상태를 저장할 DB
      * 컨트랙트 코드
    * stateObject를 통해 이더리움의 stage databese인 LevelDB에 업데이트

* 이더리움의 상태 전이(State Transition)

  * 블록 채굴로 인한 거래 내역 추가 시 상태 전이 발생
  * 상태전이함수에 의해 수행
    * APPLYS(S, TX) -> S' or Error

* 트랜잭션 종류

  * (외부) 트랜잭션
    * EOA가 다른 EOA 혹은 CA로 보내는 `서명된 메시지`
      * EOA -> EOA : ETH 잔액 변경(ETH 송금)
      * EOA -> CA : 컨트랙트 코드 실행
    * 계정의 상태 변화를 유도하는 일종의 트리거
  * 내부 트랜잭션
    * CA가 다른 CA 혹은 EOA에게 전달하는 `서명되지 않은 메시지`
    * 주로 컨트랙트 함수 호출에 사용
    * 블록체인에 별도로 저장되지 않음

* 트랙잭션 구조

  ```
  type exdata struct{
  	AccountNoncd //외부 트랜잭션의 수
  	Price // 트랜잭션 수수료
  	GasLimit // 트랜잭션 실행을 위해 지불할 최대 가스 양
  	recipient // 거래의 수신처
  	Amount // 거래하고자 하는 ETH의 양
      Payload // 메시지, 함수 호출 등
      V, R, S // 서명정보
  }
  ```

  * 소스 위치 : go-ethereum ~core/types/transactiongo
  * 블록
    * 이더리움 장부에 기록되는 데이터의 기본 단위
    * 트랜잭션들의 집합

* 엉클 블록(Uncle Block)

  * 동일한 시점에 채굴된 블록 중 채굴 난이도가 낮아 메인 체인에 연결되지 못한 블록
  * 블록생성 시간이 빠를 수록 엉클 블록의 발생확률이 높음
    * 비트코인 : 약 10분
    * 이더리움 : 약 14초
  * 문제점
    * 엉클 블록에 포함된 트랜잭션은 승인되지 않았기 때문에 트랜잭션 처리 지연 발생
    * 승인되지 않은 블록에 연산이 소모되어 연산량이 낭비됨
    * 평균 블록생성 시간이 늘어나 채굴 난이도가 감소하게 되어 네트워크의 보안 수준이 낮아 질 수 있음

* 작업 증명 (PoW, Proof of Work)

  * Ethash
    * 비트코인의 PoW의 문제점(낮은 ASIC 저항성)을 개선
    * ASIC(Application Specific Intergrated Circuit) 저항성을 높임
    * 계산은 어렵게, 검증은 쉽게
  * 지분 증명(PoS, Proof of Stake)
    * 검증가자 가진 지분(State)에 비례한 확률로 블록 생성 권환을 획득하고 생성된 블록을 원하는 체인에 연결, 보상 획득
    * PoW으 문제점을 개선
      * 전력 소모량, 채굴 중앙화 등
    * 이더리움은 Casper를 통해 PoS로 전환 중

* Casper FFG(Friendly Finality Gadget)

  * PoW + PoS의 하이브리드 방식
  * 1~99 번째 블록은 PoW, 100번째 블록은 PoS 방식으로 채굴
    * 100번째 PoS 블록을 체크포인트라고 정의함
    * 전체 PoS 검증자들 중 2/3 이상이 투표한 블록이 되며 되돌릴 수 없음 -> 랴ㅜ미ㅑㅋㄷ
  * 1~100번째 블록을 Epoch라 정의함
    * 현재는 100개의 블록이 하나의 epoch를 구성
    * 추후 이 epoch의 길이를 축소해가면서 PoS 블록의 비율을 늘릴 예정



> 이더리움 스마트 컨트랙트

* 스마트 컨트랙트

  * 스마트 컨트랙트 개발언어
    * Solidity : 현재 가장 많이 사용되고 있는 이더리움 스마트 컨트랙트 언어
    * SERPENT : 초창기 이더리움의 스마트 컨트랙트 언어
    * LLL : (EVM을 위한) 어셈블리 언어와 유사

* 스마트 컨트랙트의 배포(Deployment)

  * 스마트 컨트랙트를 이더리움에 배포하기 위해

    * Recipient -> 수신자 미정(0으로 할당)
    * Payload -> Bytecode와 ABI
    * 스마트 컨트랙트 배포를 위한 가스

    를 담은 특수한 형태의 트랜잭션을 생성, 전송

* 스마트 컨트랙트의 실행(Excution)

  * 스마트 컨트랙트를 실행하기 위해

    * Recipient -> 해당 스마트 컨트랙트의 CA
    * Payload -> 실행하려는 함수, 매개변수

    스마트 컨트랙트 실행을 위한 가스를 담은 형태의 트랜잭션을 생성, 전송

* Gas

  * 이더리움을 움직이게 하는 `기본 단위`
  * 트랜잭션, 스마트 컨트랙트를 위한 수수료
    * 최대 가스 X 가스 가격
  * 가스 가격의 기본 단위 : Gwei ( 1 Gwei = 0.000000001 ETH)
    * 이는 사용자가 정의할 수 있으며 단위가 클 수록 트랜잭션의 빠른 처리 가능
    * SafeLow -> 1 Gwei, Fast -> 4Gwei

* 스마트 컨트랙트의 경우, 가스는 함수 종류에 따라 비용 차등 부여



> 이더리움의 동작 메커니즘

1. 계정, 트랜잭션의 생성
2. 서명
3. 검증
4. 채굴



### 2. 이더리움 가상 머신

> EVM 소개

* Ethereum Virtual Machine
  * 이더리움 스마트 컨트랙트를 실행하기 위한 가상머신
  * 특징
    * 튜링 완전 머신, 스택 기반 구조, 32 Byte의 메모리
    * 이더리움 주소 연산(160bit), 256bit 암호화 알고리즘 등 이더리움 관련 구조 연산에 최적화
  * 모든 동작을 수행하기 위해서는 사전에 가스가 지불되어야 함
    * 이는 DoS(Denial of Service) 공격을 방지하기 위함
  * EVM의 프로그램은 내부에서만 실행되고 가상머신의 HOST 환경에는 접근 불가
  * EVM 간 메시지를 통해 데이터를 송수신 할 수 있음
  * 결정적(Deterministic) 머신 -> 때문에 항상 동일한 상태를 반환
* EVM stack
  * 이더리움의 모든 연산은 스택에 수행
  * 피연산자(데이터), 연산의 임시 값 역시 스택에 저장
  * 최대 크기 : 256 bit x 1024
* 스택 기반 동작의 이해
  * 입력 값 -> Bytecode
  * 입력 값의 종류에 따라 다른 동작을 수행
    * 명령어 : 연산
    * 데이터 : PUSH
* EVM Memory
  * 스마트 컨트랙트 호출 시 생성
  * 함수의 매개변수, 지역 변수 및 반환 값 등을 임시적으로 저장
  * 일반적인 PC의 RAM과 마찬가지로 휘발성
  * EVM 첫 구동 크기는 0으로 설정됨 -> 접근 시 256 비트 단위로 증가
    * Memory의 크기 증가 시 가스가 반드시 소모되며 가스량은 지수적으로 증가 
* EVM Storage
  * key-value wjwkdth
  * key : 256 bit
  * value : 256 bit
  * 스마트 컨트랙트는 자신의 storage에만 접근 가능
  * 초기값은 0 -> 접근자마다 확장될 수 있음
  * 스마트 컨트랙트에서 사용자 정의 함수 외부에 선언된 변수를 나타냄