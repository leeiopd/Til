# 	하이퍼레저 패브릭 네트워크

## #1. 타 블록체인들과의 비교

|           | 비트코인 |      이더리움      |               하이퍼레저 패브릭               |
| :-------: | :------: | :----------------: | :-------------------------------------------: |
| 자체 화폐 | 비트코인 |        이더        |                     없음                      |
| 네트워크  |   공개   |       공개형       |                    허가형                     |
|   거래    |   익명   |  익명 또는 비공개  |                공개 또는 기밀                 |
|   합의    |   POW    | POW, POS(지원예정) | SOLO, Kafka, PBFT(v1.0 이전), SBFT(지원 예정) |



## #2. 하이퍼레저 패브릭의 특징

1. 허가형 블록체인으로서 허가받은 참여자만 네트워크에 참여 할 수 있다.

2. 스마트 컨트랙트에 일반 프로그래밍 언어가 사용 가능하다.

   (현재는 go, Node,js 지원)

3. 스마트 컨트랙트를 일부 노드만 실행하므로 다수의 거래를 병렬적으로 빠르게 처리 할 수 있다.

4. 채널을 이용해 허가받은 사람들에게 장부(ledger)를 공개할 수 있다.

5. 교체 가능합 합의 프로토콜을 사용 할 수 있다.

   (SOLO, Kafka 방식, PBFT 등)

6. 허가형 블록체인으로써 네트워크 참여자의 신원을 확인할 수 있기 때문에 문제 발생시 책임소재를 분명히 할 수 있다.



## #3. 하이퍼레져 패브릭 네트워크 만들기

1. 오더링 서비

   * 오더링 서비스 - 블록내의 트랜잭션 순서를 정하고 연결된 노드들에게 전달하는 기능

     * 트랜잭션의 순서는 FCFS - First come First Serve 방식으로 결정

   * 오더링 서비스 노드 - 오더링 서비스를 호스팅하는 주체

     * 중앙화된 방식 ~ 분산화 모델까지 여러 합의 방식을 사용 가능

     * 하이퍼레져 패브릭은 기본적으로 SOLO, Kafka 기반의 합의 프로토콜 제공

       * SOLO(Single Ordering Service Node)
* Kafaka - pub-sub 모델의 메세지 큐, CFT(Crash fault tolerance) 기반의 합의 프로토콜
         * CFT - 일부 구성요소들이 동작하지 않더라도 올바른 합의에 도달 할 수 있는 성질
  * 패브릭 네트워크에 참여하기 위해서는 관리자의 승인이 필요하므로 악의적인 주체 (Malicious actors)의 공격 확률이 매우 작을 것으로 본다.
         * 더 빠르고 간단한 합의 프로토콜이 허용 가능한 범위로 간주 된다.

2. Network configuration 설정

   * 프라이빗 블록체인에서는 네트워크 참여자의 권한 관리가 매우 중요하다.
   * 그륩 별 네트워크 자원에 접근 할수 있는 ㅈ버근 권한은 관리자에 의해 정해져서 Network Configuration에 저장된다.

3. Certificate Authority 설정

   * 참여자의 ID와 권한을 관리하는 주체는 Certificate Authority - CA
   * CA는 디지털 증명서를 발급하는 기관며, 패브릭 네트워크에 참여하는 그룹들은 모두 개별 CA를 이용하게 된다.

4. Consortium 구성

   * 컨소시엄 : ‘공동의 목표를 가지고 트랜잭션 내역을 공유하며 협력하는 집단’

5. Channel 구성하기

   1. Channel

      * 채널은 하이퍼레져 패브릭에서 매우 중요한, 컨소시엄 그룹간 커뮤니케이션 메커니즘이다.
      * 채널은 데이터 분리(data isolation)와 기밀화를 가능하게 한다.
      * 채널용 장부(channel-specific ledger)는 채널 사용 허가를 받은 컨소시엄 멤버들만이 접근 가능하다.
      * 네트워크 설정과 별개로 채널설정이 존재하며, 채널 설정에는 채널에 접근 할 수 있는 peer의 권한 정보 등 채널 운영에 필요한 모든 정보를 담고 있다.
      * 채널 설정 정보는 블록에 담겨 장부에 기록 된다.
      * 프리이버시를 유지하며 효율적인 데이터 공유가 가능하게 만들어주기 때문에 채널은 퍼블릭 블록체인은 가지지 못하는 장점을 제공하는 중요한 기능이다.
      * 하나의 네트워크 안에는 여러 컨소시엄들이 사용하는 채널들이 존재 할 수 있다.

   2. Ledger(장부)

      * Ledger - 변경 불가능한 상태 데이터 베이스 (immutable state database)
      * 한 채널이 한 장부를 가진다.
      * 이 장부를 물리적으로 호스팅하는 노드들을 Peer라고 한다.
      * 한 채널 안의 여러 피어들이 한 장부의 복사본을 가진다.
      * 장부의 업데이트는 여러 피어들의 합의를 통해 이루어지기 때문에 일관성을 유지 할 수 있다.

   3. Peer(피어)

      * Peer - Ledger를 물리적으로 호스팅하고 Chaincode(하이퍼레저 패브릭의 smart contract)를 저장하고 있는 독립체 이다.
      * 피어는 CA로 부터 Identity를 배정받고 채널에 참여 할 수 있다.

   4. Chaincode (smart contract)

      * smart contract는 장부에 저장된 상태(state)를 업데이트 하는 코드이다.
      * 하이퍼레져 패브릭에서는 chaincode 라고 하며 go와 node.js를 지원한다.
      * 하이퍼레저 패브릭에서 체인코드를 사용하려면, 우선 노드 피어에 체인코드를 설치(install) 하여야 한다.
      * 피어에 체인코드를 설치하면, 해당 피어는 그 체인코드의 구현 로직(implementation logic)을 담게 된다.
      * 특정 채널을 호스팅하는 모든 피어들에 같은 체인 코드를 설치할 필요는 없으며, 몇개의 피어들만 선택하여 체인코드를 설치 할 수 있다.

   5. instantiated(인스턴스화)

      * 체인코드를 사용 하려면, 구현 로직이 아닌 해당 체인코드의 인터페이스를 다른 피어들에게 알리는 인스턴스화가 필요하다.

      

## #4. 트랜젝션 처리 과정

1. 클라이언트 어플리케이션에서 SDK를 통해 트랜잭션 제안(transaction proposal)을 발생시킨다.
2. 체인코드의 보증 정책(endorsing policy)에 명시된 노드들(endorsing peers)은 체인코드를 실행한다.
3. 각 결과값은 클라이언트 어플리케이션에 전달된다.
4. 결과값이 보증 정책을 만족시키면, 결과값은 오더링 서비스(ordering service)에 전달된다.
5. 오더링 서비스는 먼저 도착한 순으로 블록을 만들어 채널의 모든 피어들에게 전달한다.
6. 모든 피어는 도착한 블록이 보증 정책을 만족시키는지, 장부 상태(ledger state)가 트랜잭션이 일어나는 동안 바뀌지 않았는지 확인한다.
7. 각 피어들은 블록을 채널의 체인에 덧붙이며, 장부의 상태를 업데이트.