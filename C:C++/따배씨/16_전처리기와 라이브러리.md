# 따배씨 - 따라하며 배우는 C언어

### 16강 전처리기와 라이브러리

##### 16.1 전처리기 Pre-processor 가 해주는 일들

![16_1_1_전처리기](./imgs/16_1_1.png)

* Compiler 한다 : 코드를 입력하고 실행파일을 만드는 일 -> Build
* 명확하게는 전처리기는 Compiler 는 아님
  * Complier 가 어떤 일을 하는지에 따라 전처리기의 역할이 다름
    * Compiler 는 코드의 중요한 문법들을 해석해서 실행 할 수 있는 형태로 바꾸어주는 역할
    * Linker 는 파일들을 연결 시켜 주는 역할
* 전처리기
  * Code 와 Compiler 를 연결해 주는 역할
  * 프로그래머의 반복적인 작업을 도와주는 역할
  * 조건적으로 compiler 하는 기능



##### 16.2 전처리기를 준비하는 번역 단계 Translation phase

```c
#include <stdio.h>

int main()
{
    /*
        Program written in C
        
        Translating - 전처리기의 앞에서 이루어 지거나 전처리기에 포함된 과정으로 혼용하여 봄
        Preprocessing
        Compiling - Compiler 가 모두 처리한다는 표현으로 사용하기도 함
        Linking
     
        Executable
     */
    
    
    /*
        International characters
     */
    puts("안녕하세요? 한글입니다.\n");
    // 국제 다국어로 작성된 코드를 내부적으로 Translating 단계에서 이해 할 수 있는 문자 집합으로 처리
    
    
    /*
        Trigraph Sequences
        - Some keyboards don't provide all the symbols used in C.
        - Three-character sequences
     
        Trigraph        Replacement
        ??=             #
        ??/             \
        ??'             ^
        ??(             [
        ??)             ]
        ??!             |
        ??<             {
        ??>             }
        ??-             ~
     
        /Zc: trigraphs
     */
    int arr[3] = {1, 2, 3};
    printf("arr[0] == %d\n", arr[0]);
    // printf("arr??(0??) == %d\n", arr??(0??));
    
    /*
        Digraphs
        - Two-Character sequences
     
        Digrapsh        Equivalent
        <:              [
        :>              ]
        <%              {
        %>              }
        %:              #
     */
    printf("arr[1] == %d\n", arr[1]);
    //printf("arr<:1:> == %d\n", arr<:1:>);
    
    /* Two physical lines vs One logical line */
    printf("This is a very very very very very very very very\
 long long long\n");
    
    
    /*
        Tokens
        - Groups separated from each other by spaces, tabs, or lines breaks
        Whitespace charaters -> a single space
     */
    int /* a variable to count a number*/ n = 1;
    // int n = 1;
    // 권장하지 않음
    
    return 0;
}
```



##### 16.3 #define 매크로

```c
#include <stdio.h>


/*
    Preprocessor directives begins with # simbol at the beginning of a line.
 */

/*
    Macro
    - An instruction that represents a sequence of instructions in abbreviated form.
 */

/*
    #define         SAY_HELLO       printf("Hello, World!");
    
    preprocessor    Macro (name)    body (or replacement list)
    directive
 
    Macro expansion - macro 가 body 의 내용으로 교체되는 것을 의미
 */

/*
    Object-like macros vs Function-like macros
 
    #define ONE 1
    // 전처리기가 ONE 에 해당하는 부분을 1 로 교체, complier 입장에서는 변수는 아님
 
    #define SQUARE(X) X*X
    // compiler 입장에서는 함수가 아님, cpp 에서는 함수형 메크로 사용을 지양함
 */

#define PI 3.141592     /* Symbolic, or manifest, constans */
#define GRAVITY 9.8

#define THREE 3
#define MESSAGE "The greatst glory in living lies not in never falling, \
but in rising every time we fall."

#define NINE THREE*THREE
#define SAY_HELLO for(int i = 0; i < 10; i++) printf("Hello, World!\n");
#define FORMAT "Number is %d\n"

 # define WITH_BLANK 1

#define MY_CH 'Z'
#define MY_ST "Z"   // Z\0

#define LIMIT 20
const int LIM = 50;
static int arr1[LIMIT];
const int LIM2 = 2 * LIMIT;

/*
    Tokens
    
    #define SIX 3*2
    #define SIX 3 * 2
    #define SIX 3       *       2
 */

/* Redefining Constants */
#define SIX 2*3
#define SIX 2*3
// 한 file 안에서, define 을 여러번 선언 가능
// define 은 기본적으로 file scope

#define SIX 2 * 3 // Warning

#undef SIX
#define SIX 2 * 3
// undef 로 define 해제 후, 새롭게 define 하면 token 문제 해결 가능

int main()
{
    int n = THREE;
    SAY_HELLO
    n = NINE;
    
    printf(FORMAT, n);
    printf("%s\n", MESSAGE);    // replaced
    printf("SAY_HELLO NINE\n"); // Not replaced
    return 0;
}
```

* Macro 는 기본적으로 복사해서 붙여넣기 수준으로 교체해주는 것은 맞지만, 그렇지 않는 경우도 있으니 유의
* Compiler 는 Macro 의 내용을 알지 못함, 전처리기가 처리 하기 때문

* ```c
  #define SAY_HELLO for(int i = 0; i < 10; i++) printf("Hello, World!\n");
  ```

  * SAY_HELLO 를 선언 할때, ';' (세미콜론) 을 붙였기 때문에, main 에서 SAY_HELLO 뒤에 ';' 을 붙이지 않아도 문제가 없다.
  * 세미콜론이 두개가 붙여진다고 해서 문제가 생기는 것은 아님
  * 오픈소스에서는 세미콜론을 안쓰는 경우가 많으므로 주의하자

* Macro 는 문자열 안에 있는 경우는 교체되지 않음



##### 16.4 함수 같은 메크로

```c
#include <stdio.h>

/*
    Function-like macros
 
    #define     ADD(X,Y)    ((X) + (Y))
    
    X and Y : macro arguments
 */

#define ADD1(X,Y)   X+Y
#define ADD2(X,Y)   ((X)+(Y))
#define SQUARE(X)   X*X         // ((X)*(X))

int main()
{
    int sqr = SQUARE(3);
    
    int a = 1;
    
    printf("%d\n", 2 * ADD1(1, 3)); // 2 * X + Y = 2 * 1 + 3 = 5    //WRONG!!
    printf("%d\n", 2 * ADD2(1, 3)); // 2 * (1 + 3) = 8
    
    printf("%d\n", SQUARE(1 + 2));  // 1+2*1+2 = 1 + 2 + 2 = 5  //WRONG!!
    printf("%d\n", 100 / SQUARE(3 + 1)); // 100 / 3 + 1 * 3 + 1 = 33 + 3 + 1 = 37 // WRONG!!
    printf("%d\n", SQUARE(++a));    // ++a * ++a = 2 * 3 = 6 //DANGEROUS!
    
    return 0;
}
```

* Function-like Macros 는 연산의 순서가 예상과 다를 경우가 발생할 수 있으므로 주의



```c
#include <stdio.h>

/*
    Stringizing operator #
    - converts macro parameters to string literals
 */

#define SQUARE(X)   (X)*(X)
#define PRINT_SQR1(x)   printf("The square of %d is %d\n", x, SQUARE(x))
#define PRINT_SQR2(x)   printf("The square of " #x " is %d\n", SQUARE(x))

/*
    ## operator combines two tokens into a single token
 */

#define XNAME(n) x ## n
#define PRT_XN(n) printf("x" #n " = %d\n", x ## n);
int main()
{
    PRINT_SQR1(10);
    // The square of 10 is 100
    PRINT_SQR2(10);
    // The square of 10 is 100
    
    printf("\n");
    
    int XNAME(1) = 1;   // int x1 = 1;
    int XNAME(2) = 2;   // int x2 = 2;
    
    PRT_XN(1);          // printf("x1 " = %d\n", x1);
    // x1 = 1
    PRT_XN(2);          // printf("x2 " = %d\n", x2);
    // x2 = 2
    
    return 0;
}
```

* ```c
  #define PRINT_SQR2(x)   printf("The square of " #x " is %d\n", SQUARE(x))
  
  PRINT_SQR2(10);
  // The square of 10 is 100
  ```

  * 입력받은 x 를 프로그래머가 타이핑 한 것처럼 문자열 처리

* ```c
  #define XNAME(n) x ## n
  
  int XNAME(1) = 1;
  // int x1 = 1
  // XNAME(1) == x1
  ```

  * x 는 유저가 타이핑 한 것, n 은 입력받은 것으로 처리



```c
/*
    Macro or Function ?
    - no space in the macro name
    - Use parentheses
    - Use captital letters for macro function names
    - Speed up?
 */

#define MAX(X, Y)   ((X) > Y ? (X) : (Y))
#define MIN(X, Y)   ((X) < Y ? (X) : (Y))
#define ABS(X)      ((X) < 0 ? -(X) : (X))
```



##### 16.5 가변 인수 매크로 Variadic Macros

```c
#include <stdio.h>
#include <math.h>

/*
    Variadic Macros accept a variable number of arguments.
 */

#define PRINT(X, ...) printf("Message " #X ": " __VA_ARGS__)
// ... : ellipes
// __VA_ARGS : one of the predefined macros

/*
    printf(...)
    stdvar.h Variadic arguments
 */


int main()
{
    double x = 48;
    double y;
    
    y = sqrt(x);
    PRINT(1, "x = %g\n", x);
    // Message 1: x = 48
    PRINT(2, "x = %.2f, y = %.4f\n", x, y);
    // Message 2: x = 48.00, y = 6.9282
    
    return 0;
}
```



##### 16.6 #include 와 헤더파일

```c
// my_functions.h
#pragma once

extern int status;

static int si = 0;

extern int add(int a, int b);

static int multiply(int a, int b)
{
    return a * b;
}

//int substract(int a, int b)
inline int subtract(int a, int b)
{
    return a - b;
}

void print_status(void);
void print_address(void);
```

* ```c
  #pragma once
  ```

  * hader file 이 한번만 include 되도록 설정

    * ```c
      #ifndef __MY_FUNCTIONS__
      #define __MY_FUNCTIONS__
      // header code
      #endif
      ```

      * 같은 방법

* extern - 모든 파일에서 사용 가능한 전역 선언

  * ```c
    extern int a = 1;
    // 전역번수 선언 및 초기화
    ```

    * 다른 file 에서도 변수 사용 가능
    * file scope 에서 전역변수 선언도 extern 을 default 로 한다

  * ```c
    extern int a;
    ```

    * 다른 file 에서 선언된 전역변수에 대한 '참조선언'
    * extern 참조 선언은 함수 내에서도 가능한데, 이 경우에는 Compiler 가 다른 파일에서 extern 변수 선언을 검사하지 않음으로 Compile Error 가 발생하지 않음으로 주의

  * extern 함수의 경우, 모든 함수는 기본적으로 extern 으로 선언됨

* static - 한 파일 내에서만 사용가능한 전역 선언

  * ```c
    static int b = 2;
    ```




```c
// my_functions.c
#include "my_functions.h"

#include <stdio.h>

int status = 0;

int add(int a, int b)
{
    return a + b;
}

void print_status()
{
    printf("my_functions header status address, value: %p, %d\n", &status, status);
}

void print_address()
{
    printf("print_address()\n");
    printf("Static function address %p\n", multiply);
    printf("Static valiable address %p\n", &si);
}
```





```c
// my_structures.h
#pragma once

typedef struct
{
    char name[100];
    int age;
} patient_info;

```



```c
// my_headers/my_macros.h
#pragma once

#define MAX(X, Y)   ((X) > (Y) ? (X) : (Y))
#define MIN(X, Y)   ((X) < (Y) ? (X) : (Y))
#define ABS(X)   ((X) < 0 ? -(X) : (X))

#define GRAVITY 9.8
#define PI      3.141592

```



```c
// main.c
#include <stdio.h>  // 공식직원, 표준 라이브러리
#include "my_functions.h"
#include "my_structures.h"
#include "my_headers/my_macros.h"   //path

extern int status;

int main()
{
    printf("PI = %f\n", PI);
  	// PI = 3.141592

    printf("main status address, value: %p, %d\n", &status, status);
  	// main status address, value: 0x100008018, 0
    
  	print_status();
	  // my_functions header status address, value: 0x100008018, 0

    printf("%d\n", multiply(51, 2));
		// 102
  
    printf("\nmain()\n");
  	// main()
    printf("Static function address %p\n", multiply);
  	// Static function address 0x100003de0
    printf("Static variable address %p\n", &si);
    // Static variable address 0x100008010

	  print_address();
  	// print_address()
  	// Static function address 0x100003ea0
  	// Static valiable address 0x100008014
    
    return 0;
}
```

* ``` c
  printf("\nmain()\n");
  // main()
  printf("Static function address %p\n", multiply);
  // Static function address 0x100003de0
  printf("Static variable address %p\n", &si);
  // Static variable address 0x100008010
  
  print_address();
  // print_address()
  // Static function address 0x100003ea0
  // Static valiable address 0x100008014
  ```
  * my_functions.h 에서 static 으로 선언한 변수 si 와 함수 multiply 호출 시, 호출 방법에 따라 다른 메모리 주소에 할당되는 것을 확인 할 수 있음
  * static 으로 선언 시, 함수가 끝나도 메모리에서 사라지지 않고 유지 됨





##### 16.7 조건에 따라 다르게 컴파일하기 Conditional Compilation

```c
#include <stdio.h>

/*
    #define, #undef, #if, #ifdef, #ifndef, #else, #elif, #endif
 */

/*
    #undef
 */

#define LIMIT 400
//#undef LIMIT // It's ok to undefine previously NOT defined macro.

#undef  NON_DEFINED

int main()
{
    printf("%d\n", LIMIT);
    
    return 0;
}
```

* ```c
  #undef  NON_DEFINED
  ```
  * NON_DEFINED 를 define 해주지 않았지만, 문제 없음



```c
```

