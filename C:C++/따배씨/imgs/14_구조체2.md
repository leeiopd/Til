# 따배씨 - 따라하며 배우는 C언어

### 14강 구조체_2

##### 14.11 신축성 있는 배열 멤버 Flexible Array Members

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    /*
        Flexible array member (struct hack in GCC)
        // 지금은 표준
     */
    
    struct flex
    {
        size_t count;
        double average;
        double values[];    // flexible array member (last member!)
        // 구조체가 저장되는 메모리 구조상, flexible array 변수 위치를 마지막으로 두어야 사용하기 편함
    };
    
    const size_t n = 3;
    
    struct flex* pf = (struct flex*)malloc(sizeof(struct flex) + n * sizeof(double));
    // values 의 배열 크기 n 만큼 추가 동적할당
    
    if (pf == NULL) exit(1);
    
    printf("flexible array member\n");
    printf("Sizeof struct flex %zd\n", sizeof(struct flex));
    // Sizeof struct flex 16
    printf("Sizeof *pf %zd\n", sizeof(pf));
    // Sizeof *pf 8
    printf("Sizeof malloc %zd\n", sizeof(struct flex) + n * sizeof(double));
    // Sizeof malloc 40
    printf("%lld\n", (long long)pf);
    // 4388333424
    printf("%lld\n", (long long)& pf->count);
    // 4388333424
    printf("%zd\n", sizeof(pf->count));
    // 8
    printf("%lld\n", (long long)& pf->average);
    // 4388333432
    printf("Address of pf->values %lld\n", (long long)& pf->values);
    // Address of pf->values 4388333440
    printf("Value of pf->values %lld\n", (long long)pf->values);
    // Value of pf->values 4388333440
//    printf("Sizeof pf->value %zd\n", sizeof(pf->values));
    
    pf->count = n;
    // 동적 할당을 받은 크기를 저장해 둠
    pf->values[0] = 1.1;
    pf->values[1] = 2.1;
    pf->values[2] = 3.1;
    
    pf->average = 0.0;
    for (unsigned i = 0; i < pf->count; ++i)
        pf->average += pf->values[i];
    pf->average /= (double)pf->count;
    
    printf("Average = %f\n", pf->average);
    // Average = 2.100000
    
    return 0;
}
```

* ```c
  struct flex
      {
          size_t count;
          double average;
          double values[];    // flexible array member (last member!)
      };
  ```
  * 구조체가 저장되는 메모리 구조상, flexible array 변수 위치를 마지막으로 두어야 사용하기 편함

  * ```c
    double values[];
    ```

    * 배열의 크기가 지정되지 않았기 때문에, 메모리 크기가 없는상태
    * 동적할당을 받아야지 메모리 크기가 할당 됨



```c
struct nonflex
{
  size_t count;
  double average;
  double *values; // Use malloc()
};

struct  nonflex nf;
int n = 3;
nf.values = (double *)malloc(sizeof(double) * n);
```

* ```c
  double *values;
  nf.values = (double *)malloc(sizeof(double) * n);
  ```

  * 동적 할당 배열

  * ```c
    double *values;
    ```

    * pointer 변수가 저장될 메모리 크기를 할당 받음
    * 동적 할당된 array 의 주소는 구조체의 메모리 주소와 별도로 생성
      * 연관 X

```c
struct flex* pf = (struct flex*)malloc(sizeof(struct flex) + n * sizeof(double));

if(pf == NULL) exit(1);

*pf2 = *pf1;	// Don't copy flexible members, use memcpy() instead

printf("%f %f %f\n", pf->values[0], pf->values[1], pf->values[2]);
// 1.100000 2.100000 3.100000

printf("%f %f %f\n", pf2->values[0], pf2->values[1],pf2->values[2]);
// 0.000000 0.000000 0.000000
```

* flexible array member 는 대입 하는 방법으로는 제대로 복사 되지 않음
  * compiler 입장에서 동적 할당을 받은 size 까지 알 수 없기 때문에, 기본 size 까지만 복사가 됨
  * memcpy() 를 사용하여 값을 복사해야 함



##### 14.12 익명 구조체 Anonymous Structures

```c
#include <stdio.h>

struct names
{
    char first[20];
    char last[20];
};

struct person
{
    int id;
    struct names name;  // nested strucutre member
};

struct person2
{
    int id;
    struct { char first[20]; char last[20]; };    // anomymous strucutre
};

int main()
{
    struct person ted = { 123, {"Bill", "Gates"}};
    struct person ted3 = { 125, {"Robert", "Hand"}};
    
    puts(ted.name.first);
    // Bill
    puts(ted3.name.first);
    // Robert
    
    struct person2 ted2 = { 124, {"Steve", "wozniak"}};
    // Steve
		// struct person2 ted2 = { 124, "Steve", "wozniak"};   // also works
    
    puts(ted2.first);
    
    return 0;
}
```

* ```c
  struct person2
  {
      int id;
      struct { char first[20]; char last[20]; };    // anomymous strucutre
  };
  
  struct person2 ted2 = { 124, {"Steve", "wozniak"}};
  // or //struct person2 ted2 = { 124, "Steve", "wozniak"};
  
  puts(ted2.first);
  ```
  * ```c
    puts(ted2.first);
    ```

    * 익명 구조체가 멤버일 때에는, 익명 구조체의 멤버로 바로 접근이 가능함



##### 14.13 구조체의 배열을 사용하는 함수

```c
#include <stdio.h>

#define SLEN 101

struct book
{
    char name[SLEN];
    char author[SLEN];
};

void print_books(const struct book books[], int n);

int main()
{
    struct book my_books[3];    // = {"The Great Gatsby", "F. Scott Fitzgerald"},...};
    
    my_books[0] = (struct book){"The Great Gatsby", "F. Scott Fitzgerald"};
    my_books[1] = (struct book){"Hamlet", "William Shakespeare"};
    my_books[2] = (struct book){"The Odyssey", "Homer"};
    
    print_books(my_books, 3);
    
    return 0;
}

void print_books(const struct book books[], int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("Book %d :\"%s\" written by \"%s\"\n", i + 1, books[i].name, books[i].author);
    }
}
```

* 구조체 배열 사용



```c
#include <stdio.h>
#include <stdlib.h>

#define SLEN 101

struct book
{
    char name[SLEN];
    char author[SLEN];
};

void print_books(const struct book books[], int n);

int main()
{
    struct book* my_books = (struct book*)malloc(sizeof(struct book) * 3);
    
    if (!my_books) exit(1);
    
    my_books[0] = (struct book){"The Great Gatsby", "F. Scott Fitzgerald"};
    my_books[1] = (struct book){"Hamlet", "William Shakespeare"};
    my_books[2] = (struct book){"The Odyssey", "Homer"};
    
    print_books(my_books, 3);
    
    return 0;
}

void print_books(const struct book* books, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("Book %d :\"%s\" written by \"%s\"\n", i + 1, books[i].name, books[i].author);
    }
}
```

* 구조체 배열을 pointer 로 구현



 